---
title: "Mathematical Modeling of Mixtures Analysis Example"
author: "Rachel Broughton"
date: "2025-07-15"
output: html_document
---
# Setup Environment {.tabset}

## Load Packages
```{r setup, results="hide", message=FALSE}
rm(list = ls())
# load packages
library(tidyverse)
library(data.table)
# library(dplyr)
# library(tidyr)
library(readxl)
library(tcplfit2)
library(tcpl)
library(grid)
library(cowplot)
library(scales)

# import scripts with functions
source("./scripts/curve_fitting_functions.R")
source("./scripts/mixture_model_functions.R")
source("./scripts/mixture_plotting_functions.R")
```

Set up connections to ToxCast database
```{r,include=FALSE, results="hide", message=FALSE}
# set up connections to ToxCast database
tcplConf("", pass="", db="prod_internal_invitrodb_v4_2", drvr="", host="")
tcplConfList()
```

## Load Data for example

```{r, results="hide"}

# load test dataset spids
load("./input/mixture_spids.Rdata")
# load saved selected legacy spids instead of running each time
load("./input/legacy_spids.Rdata")
all_spids <- c(spids,spids_tc)

# read key for mapping mixtures to single components
ES219_key <- read_excel("./input/ATG_mixtures_upload.xlsx",  sheet = "ES219_key")
mixtures_uploads <- read_excel("./input/ATG_mixtures_upload.xlsx",  sheet = "Mixtures_upload")
mixtures_key <- merge(ES219_key, mixtures_uploads, by.x="BOTTLE_ID", by.y="Barcode_mixture")
# Add mixture concentration fractions to key
# compute concentration of component in stock mixture
mixtures_key <- mixtures_key %>% mutate(ci_mix = ALIQUOT_CONCENTRATION.y*Aliquot_Volume/Quantity)
# compute total concentration of stock mixture (from individual components)
ctot_mix <- rowsum(mixtures_key$ci_mix, as.integer(gl(nrow(mixtures_key), 2, nrow(mixtures_key))))
mixtures_key$ctot_mix <- rep(ctot_mix, each=2)
# compute concentration fraction of individual components in stock mixture
mixtures_key <- mixtures_key %>% mutate(cfrac_mix = ci_mix/ctot_mix)

# load m4id's for mixtures, test components, and legacy components
load("./input/m4ids_all.Rdata")
mc3 <- tcplPrepOtpt(tcplLoadData(lvl=3, type = 'mc', fld='spid',val=all_spids))
mc4 <- tcplPrepOtpt(tcplLoadData(lvl=4, type = 'mc', fld='m4id',val=m4ids_all))
mc4_agg <- tcplPrepOtpt(tcplLoadData(lvl="agg", type = 'mc', fld='m4id',val=m4ids_all))
mc5 <- tcplPrepOtpt(tcplLoadData(lvl=5, type = 'mc', fld='m4id',val=m4ids_all))

# load mix.info data frames with test dataset information
load("./output/mix_info.Rdata")
# load mix.info.tc data frames with legacy ToxCast data information
load("./output/mix_info_tc.Rdata")
# load single.info data frames with test dataset component information
load("./output/single_info.Rdata")
# load single.info.tc data frames with legacy ToxCast component information
load("./output/single_info_tc.Rdata")
# load mixture model results for ACC estimates
load("./output/mix_results_acc.Rdata")
#load mixture model results for full concentration-response curve predictions
load("./output/mix_results_all.Rdata")
# load quality-of-fit metric results
load("./output/fit_quality.Rdata")

```

## Load concentration-response from test dataset single components and mixture
```{r, results="hide"}
# select example mixture, based on m4id
# ex_index <- 154
m4id_mix <- 12663243
# relate mixture to single components and identify by m4id
dtxsids <- mixtures_key[mixtures_key$DTXSID.x == mc5[m4id==12663243,]$dsstox_substance_id, ]$DTXSID.y
m4id_1 <- mc5[(dsstox_substance_id==dtxsids[1] & aeid == mc5[m4id==12663243,]$aeid & (spid %in% spids)),]$m4id
m4id_2 <- mc5[(dsstox_substance_id==dtxsids[2] & aeid == mc5[m4id==12663243,]$aeid & (spid %in% spids)),]$m4id
# load concentration-response best fit curve information from tcpl level mc5
component1 <- mc5 %>% filter(m4id == m4id_1)
component2 <- mc5 %>% filter(m4id == m4id_2)
# load cocnentration-response data points from tcpl level mc3
comp1_data <- (mc3 %>% filter(m3id %in% mc4_agg[m4id==m4id_1,]$m3id))
comp2_data <- (mc3 %>% filter(m3id %in% mc4_agg[m4id==m4id_2,]$m3id))
# save concentration fractions
ci_frac <- mixtures_key[mixtures_key$DTXSID.x == mc5[m4id==12663243,]$dsstox_substance_id, ]$cfrac_mix
cfrac_1 <- ci_frac[1]
cfrac_2 <- ci_frac[2]

# Define normalization factor to normalize curves to the maximum top value
# across entire endpoint to be able to compute and compare mixture models
# pull all mc5 top response values for the Attagene endpoint of this example
mc5_all <- tcplPrepOtpt(tcplLoadData(lvl=5, type = 'mc', fld='aeid',val=component1$aeid))
norm_factor <- max(mc5_all$top, na.rm=TRUE)

# # pull mixtures info and data
# mix_info <- mix.info.tc[mix.info.tc$m4id_mix==mix.results.all$m4id_mix[ex_index],]
mix_dat <- mc3 %>% filter(m3id %in% mc4_agg$m3id[which(mc4_agg$m4id==m4id_mix)])

```

# Single Chemical Components {.tabset}

## Fit with tcplfit2

Best fit concentration-response from tcplfit2 obtained via maximum likelihood estimation (MLE)
Concentration-response is in the invitrodb database and curve fit information is stored in mc5 of the ToxCast pipeline

Plot test dataset single components
```{r, results="hide"}
# calculate response for minimum to maximum tested concentrations based on tcplfit2 best fit model and parameters
curve1_plot <- data.frame(x=seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300),
                     resp=toxcast_model(dat=component1,params=component1,
                                        XX=seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)))
curve2_plot <- data.frame(x=seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300),
                     resp=toxcast_model(dat=component2,params=component2,
                                        XX=seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)))

# set x-axis limits based on mixture data
lower_limit <- min(mix_dat$conc)
upper_limit <- max(mix_dat$conc)

p_outline <- ggplot() +
  # scale_x_log10(labels = label_number(drop0trailing = TRUE),
  #               limits= c(min(comp1_data$conc,comp2_data$conc),
  #                         max(comp1_data$conc,comp2_data$conc)))+
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=12) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(0.5,0.5,0.5,0.5), "cm"),
        plot.subtitle=element_text(hjust=0.5, size=11)) 

p1 <- p_outline +
    geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=2) +
    geom_line(data = curve1_plot, aes(x=x,y=resp/norm_factor),color="#D55E00", lwd=1.5) +
    labs(title="Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
    geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
    theme(plot.title=element_text(size=18,hjust=0.5, face="bold", color="#D55E00")) 

p2 <- p_outline +
    geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=2) +
    geom_line(data = curve2_plot, aes(x=x,y=resp/norm_factor),color="#009E73", lwd=1.5) +
    geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
    labs(title="Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
    theme(plot.title=element_text(size=18,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p1,p2)

```

## Fit with bootstrap resampling
```{r}
comp1_bootparams <- curve_bootstrap(curve.info=component1, boot_num=1000,type="single")
comp2_bootparams <- curve_bootstrap(curve.info=component2, boot_num=1000,type="single")

num_plot <- 200

indices <- sample(1:1000,num_plot)
p3 <- p_outline
  for(ii in 1:num_plot){
  XX <- seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)
  boot_curve <- toxcast_model(dat=component1,params=comp1_bootparams[indices[ii],],XX=XX)
  p3 <- p3  +
    geom_line(data =data.frame(x=XX,y=boot_curve), aes(x=x,y=y/norm_factor),color="#D55E00", lwd=1, alpha=0.1)
}

p3 <- p3 +
  geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=1.5) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bootstrapped Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#D55E00")) 

indices <- sample(1:1000,num_plot)
p4 <- p_outline
  for(ii in 1:num_plot){
  XX <- seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)
  boot_curve <- toxcast_model(dat=component2,params=comp2_bootparams[indices[ii],],XX=XX)
  p4 <- p4  +
    geom_line(data =data.frame(x=XX,y=boot_curve), aes(x=x,y=y/norm_factor),color="#009E73", lwd=1, alpha=0.1)
}

p4 <- p4 +
  geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=1.5)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Boostrapped Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p3,p4)

```


## Fit with Bayesian statistical framework
```{r}
comp1_bayesparams <- bayes_curve(curve.info=component1,n_iter=10000,n_burn=10000,
                                  type="single",poly2_correct=FALSE)
comp2_bayesparams <- bayes_curve(curve.info=component2,n_iter=10000,n_burn=10000,
                                  type="single",poly2_correct=FALSE)

indices <- sample(1:10000,num_plot)
p5 <- p_outline
  for(ii in 1:num_plot){
  XX <- seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)
  curve1 <- toxcast_model(dat=component1,params=comp1_bayesparams[indices[ii],],XX=XX)
  p5 <- p5  +
    geom_line(data =data.frame(x=XX,y=curve1), aes(x=x,y=y/norm_factor),color="#D55E00", lwd=1, alpha=0.1)
}

p5 <- p5 +
  geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=1.5) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bayesian Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#D55E00")) 

indices <- sample(1:10000,num_plot)
p6 <- p_outline
  for(ii in 1:num_plot){
  XX <- seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)
  curve2 <- toxcast_model(dat=component2,params=comp2_bayesparams[indices[ii],],XX=XX)
  p6 <- p6  +
    geom_line(data =data.frame(x=XX,y=curve2), aes(x=x,y=y/norm_factor),color="#009E73", lwd=1, alpha=0.1)
}

p6 <- p6 +
  geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=1.5)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bayesian Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p5,p6)
```


# Concentration Addition (CA) {.tabset}

## Model

The CA model for a mixture made up of 2 chemical components is written as:
$$
ACy_{mix} = (\frac{q_1}{ACy_{1}}+\frac{q_2}{ACy_{2}})^{-1}
$$
Here, $ACy_{mix}$ is the activity concentration of the mixture at a given response y and $ACy_{1}$ and $ACy_{1}$ are the activity concentrations of the individual components 1 and 2 for a given response y when applied singly and $q_i$ is the concentration fraction of the component in the mixture.

An extrapolated CA model from (Scholze et al. 2014) [https://doi.org/10.1371/journal.pone.0088808] is used to implement the CA model up to the maximum response (top) of the more efficacious single component.

If $0.7*top_2 < y < top_1$, then
$$
ACy_{mix} = \frac{ACy_{1}}{q_1} \cdot (1-TU_2)
$$

If $0.7*top_1 < y < top_2$, then
$$
ACy_{mix} = \frac{ACy_{2}}{q_2} \cdot (1-TU_1)
$$


## CA model from tcplfit2 best fit response
```{r, results="hide"}
ex_index <- which(mix.results.all$m4id_mix == m4id_mix)
cutoff <- component1$coff
num_pts <- 200

# get component 1 minimum and maximum response of tcplfit2 best fit response
comp1_min <- single_curve_min(dat=component1,params=component1)
comp1_top <- single_curve_top(dat=component1,params=component1) # top within concentration range, not true top
# set to small positive number if the minimum is negative
if (comp1_min <= 0){
  comp1_min <- 1E-20
}
# get component 2 minimum and maximum response of tcplfit2 best fit response
comp2_min <- single_curve_min(dat=component2,params=component2)
comp2_top <- single_curve_top(dat=component2,params=component2) # top within concentration range, not true top
if (comp2_min <= 0){
  comp2_min <- 1E-20
}
# set-up y-values to calculate CA line and x-values to calculate IA model
# both components are active, so set condition to TRUE and define y-values based on both components
condition1 <- TRUE
condition2 <- TRUE
# put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
y_vals <- c(10^seq(log10(max(comp1_min,comp2_min)),log10(component1$coff),
                   length.out=(2*num_pts/3)),
            seq(component1$coff+0.01,max(comp1_top,comp2_top),
                length.out=(num_pts/3)))

# compute full curve
ca_concs <- ca_full_conc(YY=y_vals,comp1=component1,comp2=component2,params1=component1,
                         params2=component2,cfrac1=cfrac_1,cfrac2=cfrac_2,
                         condition1=condition1,condition2=condition2,sample=FALSE)
ca_plot <- data.frame(conc=ca_concs,resp=y_vals)
# compute ACC only
acc_ca <- ca_point_conc(YY=component1$coff,comp1=component1,comp2=component2,
                        params1=component1,params2=component2,
                        cfrac1=cfrac_1,cfrac2=cfrac_2,
                        condition1=condition1,condition2=condition2,sample=FALSE)

p_outline <- ggplot() +
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=10) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm"),
        plot.title = element_text(size=11,hjust=0.5, face="bold")) 

p1_ca <- p_outline +
  geom_line(data=subset(ca_plot,conc>0),aes(x=conc,y=resp),
            color="#ffb000",linewidth=1)+
  labs(title="CA Modeled Response") +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1)

```

## CA model from bootstrap resampling 
```{r, results="hide"}
## Bootstrap CA implementation
num_pts <- 200
num_sample <- 1000

# compute full curve CA bootstrap 95% confidence interval
num_cols <- min(nrow(comp1_bootparams),nrow(comp2_bootparams))
ca_boot <- sapply(1:num_cols,ca_full_conc,YY=y_vals,comp1=component1,comp2=component2,
               params1=comp1_bootparams,params2=comp2_bootparams,cfrac1=cfrac_1,cfrac2=cfrac_2,
               condition1=condition1,condition2=condition2,sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bootint <- apply(ca_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_boot,1,mean,na.rm=TRUE)
ca_bootint_ex <- data.frame(resp=y_vals,mean=ca_mean,t(ca_bootint))

# Compute boostrap samples around ACC only
acc_boot_ca_ex <- sapply(1:num_cols,ca_point_conc,YY=component1$coff,
                         comp1=component1,comp2=component2,
                         params1=comp1_bootparams,params2=comp2_bootparams,
                         cfrac1=cfrac_1,cfrac2=cfrac_2,condition1=condition1,
                         condition2=condition2,sample=TRUE)

# set number of bootstrap curves to plot
num_plot <- 100
p2 <- p_outline +
  # plot 95% confidence interval
  geom_line(data=subset(ca_bootint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor),color="black",lwd=1)+
  geom_line(data=subset(ca_bootint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor),color="black",lwd=1)
for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=y_vals/norm_factor,conc=ca_boot[,jj]),conc>=0 & conc<=1000)
  p2 <- p2 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
}
p2_ca <- p2 +
  geom_line(data=subset(ca_bootint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_bootint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor,color="interval"),lwd=1.25) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bootstrap Resamples",interval="95% Confidence Interval"))+
  labs(title="Bootstrapped CA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
# print(p2)
```

## CA model from Bayesian Approach
```{r, results="hide"}
## Bayesian CA implementation
num_pts <- 200
num_sample <- 1000
num_plot <- 100

# use same component minimum/maximum and y-values as bootstrap approach
indices <- sample(1:10000, num_sample, replace=F)
# compute full curve CA Bayesian 95% credible interval
ca_bayes <- sapply(indices,ca_full_conc,YY=y_vals,comp1=component1,comp2=component2,
               params1=comp1_bayesparams,params2=comp2_bayesparams,cfrac1=cfrac_1,
               cfrac2=cfrac_2,
               condition1=condition1,condition2=condition2,sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bayesint <- apply(ca_bayes, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_bayes,1,mean,na.rm=TRUE)
ca_bayesint_ex <- data.frame(resp=y_vals,mean=ca_mean,t(ca_bayesint))

# compute CA Bayesian 95% prediction interval
# y_vals_pred <- y_vals[((1:length(y_vals)) %%2)!=0]
# y_vals_pred <- y_vals
# use fewer points because takes longer to calculate
y_vals_pred <- c(10^seq(log10(max(comp1_min,comp2_min)),log10(component1$coff),
                   length.out=(2*100/3)),
            seq(component1$coff+0.01,max(comp1_top,comp2_top),
                length.out=(100/3)))
capred_lo <- rep(NA, length(y_vals_pred))
capred_hi <- rep(NA, length(y_vals_pred))
x_pred_ca <- matrix(NA,nrow=length(y_vals_pred),ncol=num_sample)
for (zz in 1:length(y_vals_pred)){
  x_pred_ca[zz,] <- sapply(indices,ca_point_pred,YY=y_vals_pred[zz],comp1=component1,
                      comp2=component2,params1=comp1_bayesparams,
                      params2=comp2_bayesparams,cfrac1=cfrac_1,cfrac2=cfrac_2,
                      condition1=condition1,condition2=condition2)
  capred_lo[zz] <- quantile(x_pred_ca[zz,], prob=c(0.025,0.975), na.rm=TRUE)[1]
  capred_hi[zz] <- quantile(x_pred_ca[zz,], prob=c(0.025,0.975), na.rm=TRUE)[2]
}
ca_predint_ex <- data.frame(resp=y_vals_pred,lo=capred_lo,hi=capred_hi)

# Compute bayesian samples around ACC only
acc_bayes_ca_ex <- sapply(indices,ca_point_conc,YY=component1$coff,comp1=component1,
                         comp2=component2,params1=comp1_bayesparams,params2=comp2_bayesparams,
                         cfrac1=cfrac_1,cfrac2=cfrac_2,condition1=condition1,
                         condition2=condition2,sample=TRUE)

# set number of bayesian curves to plot
p3 <- p_outline
for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=y_vals/norm_factor,conc=ca_bayes[,jj]),conc>=0 & conc<=1000)
  p3 <- p3 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
}
p3_ca <- p3 +
  geom_line(data=subset(ca_bayesint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_bayesint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor,color="interval"),lwd=1.25) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bayesian Posterior Predictions",interval="95% Credible Interval"))+
  labs(title="Bayesian Approach CA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm"),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm')) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
# print(p3)

p4_ca <- p_outline
  # plot 95% prediction interval
# for(jj in 1:num_plot){
#   plot_data <- subset(data.frame(resp=y_vals_pred/norm_factor,conc=x_pred_ca[,jj]),conc>=0 & conc<=1000)
#   p4_ca <- p4_ca +
#     geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
# }
for(jj in 1:length(y_vals_pred)){
  plot_data <- subset(data.frame(resp=rep(y_vals_pred[jj],length(x_pred_ca[jj,]))/norm_factor,conc=x_pred_ca[jj,]),conc>=0 & conc<=1000)
  p4_ca <- p4_ca +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.5)
}
p4_ca <- p4_ca +
  geom_line(data=subset(ca_predint_ex,lo>=0), aes(x=lo,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_predint_ex,hi<=1000), aes(x=hi,y=resp/norm_factor,color="interval"),lwd=1.25) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bayesian Posterior Predictions",interval="95% Prediction Interval"))+
  labs(title="Bayesian Prediction Interval CA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm"),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm')) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
```

## Plots 

Plot each fitting approach used to derive the CA model. Bootstrapped and Bayesian approaches are plotted as the curve samples and the 95% interval around the concentration-response. Note that the Bayesian posterior predictive samples are calculated and plotted as concentrations as a function of response

```{r}
# plot all together
plot_grid(p1_ca,p2_ca,p3_ca,p4_ca,nrow=2,ncol=2)
```

# Independent Action (IA) {.tabset}

## Model

The IA model is calculated as

$$ A_{mix}(c_{mix}) = 1 - \prod_{i=1}^{N}(1-A_i(q_i*c_{mix})) $$
where $A_mix$ is the predicted activity, or response, for a given concentration $c_{mix}$, $A_i$ is the single component response when applied singly at a concentration of $q_i*c_{mix}$, and $q_i$ is the concentration fraction of the component in the mixture.  


## IA model from tcplfit2 best fit response
```{r, results="hide"}
# both components are active, so set condition to TRUE and define x-values based on both components
condition1 <- TRUE
condition2 <- TRUE
x_vals <- 10^seq(log10(mc5[m4id==m4id_mix,]$conc_min),
                       log10(min(component1$conc_max/cfrac_1,component2$conc_max/cfrac_2)),
                       length.out=num_pts)
# IA model derived from tcplfit2 best fit response
ia_resps <- ia_full_resp(val=x_vals,comp1=component1,comp2=component2,
                         params1=component1,params2=component2,
                         cfrac1=cfrac_1,cfrac2=cfrac_2,
                         condition1=condition1,condition2=condition2,
                         norm_factor=norm_factor,sample=FALSE)
ia_plot <- data.frame(conc=x_vals,resp=ia_resps)
# calculate ACC only from IA
# cutoff IA at top (don't include biphasic part)
ia_resps_acc <- ia_resps[1:which.max(ia_resps)]
x_vals_eval <- x_vals[1:which.max(ia_resps)]
if (max(ia_resps_acc,na.rm=TRUE)<(component1$coff/norm_factor)){
  acc_ia <- 10000
} else if (min(ia_resps_acc,na.rm=TRUE)>(component1$coff/norm_factor)){
  acc_ia <- -10000
} else {
  acc_ia <- approx(x=ia_resps_acc,y=x_vals_eval,xout=component1$coff/norm_factor, 
                   rule=1,ties="ordered")[[2]]
}

p_outline <- ggplot() +
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=10) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm"),
        plot.title = element_text(size=11,hjust=0.5, face="bold")) 
p1_ia <- p_outline +
  geom_line(data=data.frame(conc=x_vals,resp=ia_resps), aes(x=conc,y=resp),
            color="#006299",linewidth=1) +
  labs(title="IA Modeled Response") +
  geom_hline(yintercept=component1$coff/norm_factor,
             linetype="dashed", color="gray34",linewidth=1)

```

## IA model bootstrap implementation
```{r, results="hide"}
## Bootstrap CA implementation
num_pts <- 200
num_sample <- 1000
# compute full curve IA bootstrap 95% confidence interval
ia_boot <- sapply(c(1:min(nrow(comp1_bootparams),nrow(comp2_bootparams))),ia_full_resp,
                  val=x_vals,comp1=component1,comp2=component2,
                  params1=comp1_bootparams,params2=comp2_bootparams,
                  cfrac1=cfrac_1,cfrac2=cfrac_2,
                  condition1=condition1,condition2=condition2,
                  norm_factor=norm_factor,sample=TRUE)
ia_bootint <- apply(ia_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_mean <- apply(ia_boot,1,mean,na.rm=TRUE)
ia_bootint_ex <- data.frame(conc=x_vals,mean=ia_mean,t(ia_bootint))
# Compute bootstrap samples around ACC only
acc_boot_ia <- c()
for (ss in 1:num_sample){
  if (sum(!is.na(ia_boot[,ss]))==0){
    acc_boot_ia_temp <- NA
  } else{
    # cutoff IA at top (don't include biphasic part)
    ia_boot_temp <- ia_boot[,ss][1:which.max(ia_boot[,ss])]
    x_vals_eval <- x_vals[1:which.max(ia_boot[,ss])]
    if (max(ia_boot_temp ,na.rm=TRUE)<(component1$coff/norm_factor)){
      acc_boot_ia_temp <- 10000
    } else if (min(ia_boot,na.rm=TRUE)>(component1$coff/norm_factor)){
      acc_boot_ia_temp <- -10000
    } else {
      acc_boot_ia_temp <- approx(x=ia_boot_temp, y=x_vals_eval, 
                                 xout=component1$coff/norm_factor, 
                                 rule=1,ties="ordered")[[2]]
    }
  }
  acc_boot_ia <- append(acc_boot_ia,acc_boot_ia_temp)
}

# set number of bootstrap curves to plot
num_plot <- 100
p_ia_2 <- p_outline
  # plot 95% confidence interval

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_boot[,jj],conc=x_vals))
  p_ia_2 <- p_ia_2 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.05)
}
p_ia_2 <- p_ia_2 +
  geom_line(data=ia_bootint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_bootint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#006299",interval="#00314d"),labels=c(samples="Bootstrap Resamples",interval="95% Confidence Interval"))+
  labs(title="Bootstrapped IA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
```

## IA model Bayesian implementation

```{r, results="hide"}
# compute full curve IA Bayesian 95% credible interval
indices <- sample(1:10000, num_sample, replace=F)
ia_bayes <- sapply(indices,ia_full_resp,
                   val=x_vals,comp1=component1,comp2=component2,
                   params1=comp1_bayesparams,params2=comp2_bayesparams,
                   cfrac1=cfrac_1,cfrac2=cfrac_2,
                   condition1=condition1,condition2=condition2,
                   norm_factor=norm_factor,sample=TRUE)
ia_credint <- apply(ia_bayes, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_bayes_mean <- apply(ia_bayes,1,mean,na.rm=TRUE)
ia_bayesint_ex <- data.frame(conc=x_vals,mean=ia_bayes_mean,t(ia_credint))
# compute full curve IA Bayesian 95% prediction interval
ia_pred_curve <- sapply(indices, ia_full_pred, comp1=component1,comp2=component2,
                   cfrac1=cfrac_1,cfrac2=cfrac_2,params1=comp1_bayesparams,
                   params2=comp2_bayesparams,norm_factor=norm_factor, x_vals=x_vals,
                   condition1=condition1,condition2=condition2)

# get prediction interval
iapred_int <- apply(ia_pred_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_predint_ex <- data.frame(conc=x_vals,t(iapred_int))

# Compute Bayesian samples around ACC only
acc_bayes_ia <- c()
for (ss in 1:num_sample){
  if (sum(!is.na(ia_bayes[,ss]))==0){
    acc_ia_bayes_temp <- NA
  } else{
    # cutoff IA at top (don't include biphasic part)
    ia_resp <- ia_bayes[,ss][1:which.max(ia_bayes[,ss])]
    x_vals_eval <- x_vals[1:which.max(ia_resp)]
    if (max(ia_resp,na.rm=TRUE)<(component1$coff/norm_factor)){
      acc_ia_bayes_temp <- 10000
    } else if (min(ia_resp,na.rm=TRUE)>(component1$coff/norm_factor)){
      acc_ia_bayes_temp <- -10000
    } else {
      acc_ia_bayes_temp <- approx(x=ia_resp,y=x_vals_eval, 
                                  xout=component1$coff/norm_factor,
                                  rule=1,ties="ordered")[[2]]
    }
  }
  acc_bayes_ia <- append(acc_bayes_ia,acc_ia_bayes_temp)
}


# set number of Bayesian curves to plot
num_plot <- 100
# plot 95% credible interval
p_ia_3 <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_bayes[,jj],conc=x_vals))
  p_ia_3 <- p_ia_3 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.05)
}
p_ia_3 <- p_ia_3 +
  geom_line(data=ia_bayesint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_bayesint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#006299",interval="#00314d"),labels=c(samples="Bayesian Samples",interval="95% Credible Interval"))+
  labs(title="Bayesian Approach IA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
# print(p_ia_3)

# plot 95% prediction interval
p_ia_4 <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_pred_curve[,jj],conc=x_vals))
  p_ia_4 <- p_ia_4 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.3)
}
p_ia_4 <- p_ia_4 +
  geom_line(data=ia_predint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_predint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#CDEDFF",interval="#006299"),labels=c(samples="Bayesian Predictive Samples",interval="95% Prediction Interval"))+
  labs(title="Bayesian Prediction Interval IA") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm"),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm')) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
# print(p_ia_4)
  
```

## Plot all IA methods together
```{r}
plot_grid(p1_ia,p_ia_2,p_ia_3,p_ia_4,nrow=2,ncol=2)
```

# Most Potent Single Component (MP) {.tabset}

## Model

Mixture is treated as being made up 100% of the most potent single chemical component. The most potent chemical component is selected as the component with the lower activity concentration at the cutoff (ACC), which is the selected point of departure.

## MP model derived from tcplfit2 best fit response
```{r, results="hide"}
# select most potent single chemical based on ACC
single_chems <- subset(mc5,m4id %in% c(m4id_1,m4id_2))
potent_sing <- single_chems[which.min(single_chems$acc),]
# best fit to single component from tcplfit2
x_vals <- seq(potent_sing$conc_min,potent_sing$conc_max, length.out=300)
mp_curve <- toxcast_model(dat=potent_sing,params=potent_sing,XX=x_vals)
mp_plot <- data.frame(conc=x_vals,resp=mp_curve)
## acc of MP model
acc_mp <- potent_sing$acc
# Plot MP model
p_outline <- ggplot() +
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=10) +
  theme(
        legend.position="none", axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm"),
        plot.title = element_text(size=11,hjust=0.5, face="bold")) 
p1_mp <- p_outline +
  geom_line(data=data.frame(conc=x_vals,resp=mp_curve/norm_factor),aes(x=conc,y=resp),
            color="#be548f",linewidth=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1)+
  theme(axis.text = element_text(color="black"))
```

## MP model bootstrap implementation
```{r, results="hide"}
## Bootstrap CA implementation
num_pts <- 200
num_sample <- 1000

x_vals <- 10^seq(log10(0.01*potent_sing$conc_min),log10(3*potent_sing$conc_max),length.out=num_pts)
# select most potent single chemical bootstrapped parameters
if (which.min(single_chems$acc)==1){
  bootparams <- comp1_bootparams
} else {
  bootparams <- comp2_bootparams
}
# bootstrap interval
single_boot <- sapply(c(1:nrow(bootparams)), toxcast_model,
                      dat=potent_sing,params=bootparams,
                      XX=x_vals,sample=TRUE)
single_bootint <- apply(single_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
single_bootint_ex <- data.frame(conc=x_vals,t(single_bootint))
# boostrap ACC only
acc_boot_single <- rep(NA,nrow(bootparams))
for (ss in 1:nrow(bootparams)){
  params <- bootparams[ss,]
  top_val <- single_curve_top(dat=potent_sing,params=params)
  min_val <- min(single_boot[,ss],na.rm=T)
  if (top_val<0){
    acc_boot_single[ss] <- NA
  } else {
    if (top_val<potent_sing$coff){
      if (potent_sing$modl %in% c("poly1","pow","exp2","exp3")){
        acc_boot_single[ss] <- single_curve_inv(y=potent_sing$coff,params=params,
                                    single_dat=potent_sing)
      } else if(potent_sing$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc_boot_single[ss] <- single_curve_inv(y=potent_sing$coff,
                                      params=params,single_dat=potent_sing)
        } else{
          acc_boot_single[ss] <- 10000
        }
      } else {
        acc_boot_single[ss] <- 10000
      }
    } else if (min_val>potent_sing$coff){
      acc_boot_single[ss] <- -10000
    } else{
      acc_boot_single[ss] <- single_curve_inv(y=potent_sing$coff,params=params,single_dat=potent_sing)
    }
  }
}

# set number of bootstrap curves to plot
num_plot <- 100
p2_mp <- p_outline
  # plot 95% confidence interval
for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=single_boot[,jj],conc=x_vals),conc<=upper_limit)
  p2_mp <- p2_mp +
    geom_line(data=plot_data,aes(x=conc,y=resp/norm_factor,color="samples"),alpha=0.05)
}
p2_mp <- p2_mp +
  geom_line(data=subset(single_bootint_ex,conc<=upper_limit), aes(x=conc,y=X2.5./norm_factor,color="interval"),lwd=1)+
  geom_line(data=subset(single_bootint_ex,conc<=upper_limit), aes(x=conc,y=X97.5./norm_factor,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#be548f",interval="#8f3668"),labels=c(samples="Bootstrap Resamples",interval="95% Confidence Interval"))+
  labs(title="Bootstrapped MP") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
```

## MP model Bayesian implementation
```{r, results="hide"}
# compute full curve MP Bayesian 95% credible interval
indices <- sample(1:10000, num_sample, replace=F)
# select most potent single chemical bootstrapped parameters
if (which.min(single_chems$acc)==1){
  bayesparams <- comp1_bayesparams
} else {
  bayesparams <- comp2_bayesparams
}
single_curve_bayes <- sapply(indices, toxcast_model,
                      dat=potent_sing,params=bayesparams,
                      XX=x_vals,sample=TRUE)
single_bayesint <- apply(single_curve_bayes, 1, quantile,
                             prob=c(0.025,0.975), na.rm=TRUE)
single_bayesint_ex <- data.frame(conc=x_vals,t(single_bayesint))

# Compute Bayesian samples around ACC only
acc_bayes_single <- rep(NA,num_sample)
for (ss in 1:num_sample){
  params <- bayesparams[indices[ss],]
  top_val <- single_curve_top(dat=potent_sing,params=params)
  min_val <- min(single_curve_bayes[,ss],na.rm=T)
  if (top_val<0){
    acc_bayes_single[ss] <- NA
  } else {
    if (top_val<potent_sing$coff){
      if (potent_sing$modl %in% c("poly1","pow","exp2","exp3")){
        acc_bayes_single[ss] <- single_curve_inv(y=potent_sing$coff,params=params,single_dat=potent_sing)
      } else if(single_dat$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc_bayes_single[ss] <- single_curve_inv(y=potent_sing$coff,params=params,single_dat=potent_sing)
        } else{
          acc_bayes_single[ss] <- 10000
        }
      } else {
        acc_bayes_single[ss] <- 10000
      }
    } else if (min_val>potent_sing$coff){
      acc_bayes_single[ss] <- -10000
    } else{
      acc_bayes_single[ss] <- single_curve_inv(y=potent_sing$coff,params=params,single_dat=potent_sing)

    }
  }
}
# compute full curve MP Bayesian 95% prediction interval
single_pred_curve <- sapply(indices,single_curve_pred,curve_dat=potent_sing,params_sample=bayesparams,XX=x_vals)
single_predint <- apply(single_pred_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
single_predint_ex <- data.frame(conc=x_vals,t(single_predint))

# set number of Bayesian curves to plot
num_plot <- 100
# plot 95% credible interval
p3_mp <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=single_curve_bayes[,jj],conc=x_vals),conc<=upper_limit)
  p3_mp <- p3_mp +
    geom_line(data=plot_data,aes(x=conc,y=resp/norm_factor,color="samples"),alpha=0.05)
}
p3_mp <- p3_mp +
  geom_line(data=subset(single_bayesint_ex,conc<=upper_limit), aes(x=conc,y=X2.5./norm_factor,color="interval"),lwd=1)+
  geom_line(data=subset(single_bayesint_ex,conc<=upper_limit), aes(x=conc,y=X97.5./norm_factor,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#be548f",interval="#8f3668"),labels=c(samples="Bayesian Samples",interval="95% Credible Interval"))+
  labs(title="Bayesian Approach MP") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))

# plot 95% prediction interval
p4_mp <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=single_pred_curve[,jj],conc=x_vals))
  p4_mp <- p4_mp +
    geom_line(data=plot_data,aes(x=conc,y=resp/norm_factor,color="samples"),alpha=0.3)
}
p4_mp <- p4_mp +
  geom_line(data=single_predint_ex, aes(x=conc,y=X2.5./norm_factor,color="interval"),lwd=1)+
  geom_line(data=single_predint_ex, aes(x=conc,y=X97.5./norm_factor,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#be548f",interval="#8f3668"),labels=c(samples="Bayesian Predictive Samples",interval="95% Prediction Interval"))+
  labs(title="Bayesian Prediction Interval MP") +
  theme(legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm"),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm')) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
  
```

## Plot all MP methods together
```{r}
plot_grid(p1_mp,p2_mp,p3_mp,p4_mp,nrow=2,ncol=2)
```

# Observed Mixture Concentration-Response {.tabset}

## Fit the observed mixture concentration-response

Obtain the observed mixture tcplfit2 best fit model, bootstrapped 95% confidence interval, and Bayesian 95% credible interval

```{r, results="hide"}
# tcplfit2 best fit response
mix_info <- mc5 %>% filter(m4id == m4id_mix)
mix_info$m4id_mix <- m4id_mix
acc_mix <- mix_info$acc
# bootstrap resampling of observed mixture
mix_bootparams <- curve_bootstrap(curve.info=mix_info, boot_num=500, type="mix")
x_vals <- 10^seq(log10(0.01*mix_info$conc_min),log10(3*mix_info$conc_max),length.out=num_pts)
# bootstrap 95% confidence interval on concentration-response
mix_curve <- sapply(c(1:nrow(mix_bootparams)), toxcast_model,
                      dat=mix_info,params=mix_bootparams,XX=x_vals,sample=TRUE)
mix_bootint <- apply(mix_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
mix_bootint <- data.frame(conc=x_vals,t(mix_bootint))
# bootstrapped distribution around ACC
acc <- rep(NA,nrow(mix_bootparams))
for (ss in 1:nrow(mix_bootparams)){
  params <- mix_bootparams[ss,]
  top_val <- single_curve_top(dat=mix_info,params=params)
  min_val <- min(mix_curve[,ss],na.rm=T)
  if (top_val<0){
    acc[ss] <- NA
  } else {
    if (top_val<mix_info$coff){
      if (mix_info$modl %in% c("poly1","pow","exp2","exp3")){
        acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
      } else if(mix_dat$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
        } else{
          acc[ss] <- 10000
        }
      } else {
        acc[ss] <- 10000
      }
    } else if (min_val>mix_info$coff){
      acc[ss] <- -10000
    } else{
      acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
    }
  }
}
mix_acc_boot <- acc

# Bayesian approach to fitting the observed mixture concentration-response
mix_bayesparams <- bayes_curve(curve.info=mix_info, n_iter=10000, n_burn=10000,
                               type="mix", poly2_correct=FALSE)
indices <- sample(1:10000, num_sample, replace=F)
mix_curve <- sapply(indices, toxcast_model,
                    dat=mix_info,params=mix_bayesparams,XX=x_vals,sample=TRUE)
mix_bayesint <- apply(mix_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
mix_bayesint <- list(data.frame(conc=x_vals,t(mix_bayesint)))

acc <- rep(NA,num_sample)
for (ss in 1:num_sample){
  params <- mix_bayesparams[indices[ss],]
  top_val <- single_curve_top(dat=mix_info,params=params)
  min_val <- min(mix_curve[,ss],na.rm=T)
  if (top_val<0){
    acc[ss] <- NA
  } else {
    if (top_val<mix_info$coff){
      if (mix_info$modl %in% c("poly1","pow","exp2","exp3")){
        acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
      } else if(mix_info$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
        } else{
          acc[ss] <- 10000
        }
      } else {
        acc[ss] <- 10000
      } 
    } else if (min_val>mix_info$coff){
      acc[ss] <- -10000
    } else{
      acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
    }
  }
  
}
mix_acc_bayes <- acc
```

# Compare Models to Observed Mixture {.tabset}

## Visual comparison of models to observed mixture

The CA, IA, and MP mixture models are compared to the observed mixture concentration-response for the full curves and for the activity concentration at the cutoff (ACC), shown by the dashed horizontal line. The Bayesian approach is shown for the IA model only as an example for simplicity.

```{r}
p1 <- ggplot_build(plotlines.func(index=ex_index,mix_input=mix.info.tc,tc=TRUE) +
                      guides(color=guide_legend(override.aes=list(lwd=0.5,size=1))) + 
                      labs(title="Best fit from tcplfit2")+
                      theme(legend.title=element_blank(),
                            legend.text = element_text(size=7),
                            legend.background = element_rect(fill=NA),
                            legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm'),
                            legend.justification = c(0,1),legend.position = "inside",
                            legend.position.inside=c(0.01,0.99),
                            legend.key.width = unit(6, "mm"),
                            legend.key.height = unit(2, "mm"),
                            axis.text = element_text(color="black"),
                            plot.margin = margin(t=0.1, r=5,b=0,l=5, unit = "cm"),
                            plot.title = element_text(hjust=0.5,size=12,face="bold")))
p1$data[[1]]$linewidth <- 0.5
p1$data[[2]]$linewidth <- 0.5
p1$data[[3]]$linewidth <- 0.5
p1$data[[4]]$linewidth <- 0.5
p1$data[[5]]$linewidth <- 0.5
p1$data[[6]]$size <- 1
p1 <- ggplot_gtable(p1)

p2 <- ggplot_build(plotint.func(index=ex_index,tc=TRUE) +
                      guides(color=guide_legend(override.aes=list(lwd=0.5,size=1)),
                             fill=guide_legend(byrow = TRUE,override.aes=list(lwd=0.5))) +
                     labs(title="Bootstrapped Approach")+
                      theme_bw(base_size=10) +
                      theme(legend.title=element_blank(),
                            legend.text = element_text(size=7),
                            legend.background = element_rect(fill=NA),
                            legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm'),
                            legend.justification = c(0,1),
                            legend.position = "inside",
                            legend.position.inside=c(0.01,0.99),
                            legend.key.width = unit(8, "mm"),
                            legend.key.height = unit(3, "mm"),
                            legend.spacing.y = unit(-0.1, "mm"),
                            axis.text = element_text(color="black"),
                            plot.margin = margin(t=0.1, r=5,b=0,l=5, unit = "cm"),
                            plot.title = element_text(hjust=0.5,size=12,face="bold")))
p2$data[[1]]$linewidth <- 0.5
p2$data[[2]]$linewidth <- 0.5
p2$data[[3]]$linewidth <- 0.5
p2$data[[4]]$linewidth <- 0.5
p2$data[[5]]$linewidth <- 0.5
p2$data[[6]]$linewidth <- 0.5
p2$data[[7]]$size <- 1
p2 <- ggplot_gtable(p2)

p3 <- ggplot_build(plotbayesintia.func(index=ex_index,tc=TRUE) +
                      guides(color=guide_legend(override.aes=list(lwd=0.5,size=1))) + 
                      theme_bw(base_size=10) +
                     labs(title="IA Bayesian Approach")+
                      theme(legend.title=element_blank(),
                            legend.text = element_text(size=7),
                            legend.background = element_rect(fill=NA),
                            legend.margin = margin(0.1,0.1,0.1,0.1, unit='mm'),
                            legend.justification = c(0,1),
                            legend.position = "inside",
                            legend.position.inside=c(0.01,0.99),
                            legend.key.width = unit(8, "mm"),
                            legend.key.height = unit(3, "mm"),
                            legend.spacing.y = unit(-0.1, "mm"),
                            axis.text = element_text(color="black"),
                            plot.margin = margin(t=0.1, r=5,b=0,l=5, unit = "cm"),
                            plot.title = element_text(hjust=0.5,size=12,face="bold")))

p3$data[[3]]$linewidth <- 0.5
p3$data[[4]]$size <- 1
p3$data[[5]]$linewidth <- 0.5
p3 <- ggplot_gtable(p3)


plot_grid(p1, p2, p3, nrow=3)

```

## Quality-of-Fit Metrics

### Activity Concentration at the Cutoff (ACC) Comparison

A difference metric, $D_{log_{10}(ACC)}$, was defined to compare the observed ACC derived directly from the observed mixture concentration-response curve ($ACC_{obs}$) and the ACC from the mixture model ($ACC_{model}$). 

$$
D_{log_{10}(ACC)}=log_{10}(ACC_{obs})-log_{10}(ACC_{model})
$$
For the mixture models derived with single component concentration-responses from tcplfit2 best fits, whether or not an accurate $ACC_{model}$ prediction is obtained is determined by testing if $-0.5 \leq D_{log_{10}(ACC)} \leq 0.5$. Whether or not a conservative $ACC_{model}$ prediction from tcplfit2 best fit components is obtained is determined by testing if $-0.5 \leq D_{log_{10}(ACC)}$.

```{r}
acc_obs <- subset(mc5,m4id == m4id_mix)$acc
print(paste0("CA: D =", round(log10(acc_obs-acc_ca),3), ", Accurate and Conservative"))
print(paste0("IA: D = ", round(log10(acc_obs-acc_ia),3), ", Accurate and Conservative"))
print(paste0("MP: D = ", round(log10(acc_obs-acc_mp),3), ", Accurate and Conservative"))
```

For the bootstrap resampled mixture models, the 95% confidence intervals around the $ACC_{model}$ and $ACC_{obs}$ are used to evaluate the model performance. If the $ACC_{model}$ and $ACC_{obs}$ intervals overlap, the model is considered an accurate representation of the observed mixture. 


TO evalute if the model ACC is conservative, the lower 95% confidence interval bounds are input to the difference metric
$$
D_{log_{10}(L95 \text{-}ACC)}=log_{10}(L95 \text{-}ACC_{obs})-log_{10}(L95 \text{-}ACC_{model})
$$
If $-0.5 \leq D_{log_{10}(L95 \text{-}ACC)}$, the model is said to provide a conservative prediction for the observed mixture within a -0.5 tolerance on a log10 scale.

```{r}
lo.obs <- quantile(mix_acc_boot,probs=c(0.025),na.rm=TRUE)
hi.obs <- quantile(mix_acc_boot,probs=c(0.975),na.rm=TRUE)
lo.ca <- quantile(acc_boot_ca_ex,probs=c(0.025),na.rm=TRUE)
hi.ca <- quantile(acc_boot_ca_ex,probs=c(0.975),na.rm=TRUE)
lo.ia <- quantile(acc_boot_ia,probs=c(0.025),na.rm=TRUE)
hi.ia <- quantile(acc_boot_ia,probs=c(0.975),na.rm=TRUE)
lo.mp <- quantile(acc_boot_single,probs=c(0.025),na.rm=TRUE)
hi.mp <- quantile(acc_boot_single,probs=c(0.975),na.rm=TRUE)


boot_int_results <- data.frame(name=c("Observed","CA","IA","MP"),
                               L95=round(c(lo.obs,lo.ca,lo.ia,lo.mp),2),
                               U95=round(c(hi.obs,hi.ca,hi.ia,hi.mp),2),
                               Overlap=c(NA,(lo.obs <= lo.ca & hi.obs >= lo.ca)|
                                           (lo.obs <= hi.ca & hi.obs >= hi.ca)|
                                           (lo.ca <= lo.obs & hi.ca >= lo.obs)|
                                           (lo.ca <= hi.obs & hi.ca >= hi.obs),
                                         (lo.obs <= lo.ia & hi.obs >= lo.ia)|
                                           (lo.obs <= hi.ia & hi.obs >= hi.ia)|
                                           (lo.ia <= lo.obs & hi.ia >= lo.obs)|
                                           (lo.ia <= hi.obs & hi.ia >= hi.obs),
                                         (lo.obs <= lo.mp & hi.obs >= lo.mp)|
                                           (lo.obs <= hi.mp & hi.obs >= hi.mp)|
                                           (lo.mp <= lo.obs & hi.mp >= lo.obs)|
                                           (lo.mp <= hi.obs & hi.mp >= hi.obs)),
                               Conservative=c(NA,log10(lo.obs)-log10(lo.ca)>= -0.5,
                                              log10(lo.obs)-log10(lo.ia)>= -0.5,
                                              log10(lo.obs)-log10(lo.mp)>= -0.5)
      )
print(boot_int_results)

```

The 95% credible intervals from the Bayesian approach are evaluated in the same way as the bootstrapped confidence intervals. A model ACC estimate is considered accurate when the modeled and observed intervals overlap
```{r}
lo.obs <- quantile(mix_acc_bayes,probs=c(0.025),na.rm=TRUE)
hi.obs <- quantile(mix_acc_bayes,probs=c(0.975),na.rm=TRUE)
lo.ca <- quantile(acc_bayes_ca_ex,probs=c(0.025),na.rm=TRUE)
hi.ca <- quantile(acc_bayes_ca_ex,probs=c(0.975),na.rm=TRUE)
lo.ia <- quantile(acc_bayes_ia,probs=c(0.025),na.rm=TRUE)
hi.ia <- quantile(acc_bayes_ia,probs=c(0.975),na.rm=TRUE)
lo.mp <- quantile(acc_bayes_single,probs=c(0.025),na.rm=TRUE)
hi.mp <- quantile(acc_bayes_single,probs=c(0.975),na.rm=TRUE)


bayes_int_results <- data.frame(name=c("Observed","CA","IA","MP"),
                               L95=round(c(lo.obs,lo.ca,lo.ia,lo.mp),2),
                               U95=round(c(hi.obs,hi.ca,hi.ia,hi.mp),2),
                               Overlap=c(NA,(lo.obs <= lo.ca & hi.obs >= lo.ca)|
                                           (lo.obs <= hi.ca & hi.obs >= hi.ca)|
                                           (lo.ca <= lo.obs & hi.ca >= lo.obs)|
                                           (lo.ca <= hi.obs & hi.ca >= hi.obs),
                                         (lo.obs <= lo.ia & hi.obs >= lo.ia)|
                                           (lo.obs <= hi.ia & hi.obs >= hi.ia)|
                                           (lo.ia <= lo.obs & hi.ia >= lo.obs)|
                                           (lo.ia <= hi.obs & hi.ia >= hi.obs),
                                         (lo.obs <= lo.mp & hi.obs >= lo.mp)|
                                           (lo.obs <= hi.mp & hi.obs >= hi.mp)|
                                           (lo.mp <= lo.obs & hi.mp >= lo.obs)|
                                           (lo.mp <= hi.obs & hi.mp >= hi.obs)),
                               Conservative=c(NA,log10(lo.obs)-log10(lo.ca)>= -0.5,
                                              log10(lo.obs)-log10(lo.ia)>= -0.5,
                                              log10(lo.obs)-log10(lo.mp)>= -0.5)
      )
print(bayes_int_results)
```

### Full Concentration-Response Comparison

For the mixture models derived with single component concentration-responses from tcplfit2 best fits, the ability of the model to predict the observed concentration-response is evaluated with the residual sum of squares (RSS)

To evaluate the abilities of the mixture models to predict the full concentration-response, the residual sum of squares (RSS) for mixture models derived from the tcplfit2 best fit single components and the tcplfit2 best fits directly to the observed mixture data are compared. A ratio of 1 indicates that the mixture model fits the observed data as well as the direct tcplfit2 best fit and a threshold of 10 is set on this metric to determine which models are representative of the observed mixtures. 

$$
\frac{RSS_{model}}{RSS_{obs}} \leq 10
$$

```{r}
# select observed mixture data to evaluate
# select concentration up to mixture maximum
x_vals <- seq(min(mix_dat$conc),max(mix_dat$conc),length.out=500)
mix_model <- toxcast_model(dat=mix_info,params=mix_info,XX=x_vals)
mix_top_loc <- x_vals[which.max(mix_model)]
dat_eval <- subset(mix_dat, conc<=mix_top_loc)
# select only concentrations where the models are valid
tol <- 1E-5 # tolerance for comparing equal to (<=)
dat_eval_ca <- subset(dat_eval,conc<=(max(ca_plot$conc,na.rm=T)+tol))
dat_eval_ia <- subset(dat_eval,conc<=(max(ia_plot$conc,na.rm=T)+tol))
dat_eval_mp <- subset(dat_eval,conc<=(max(mp_plot$conc,na.rm=T)+tol))
# evaluate models at observed concentrations
ca_y_eval <- ifelse(dat_eval_ca$conc<min(ca_plot$conc,na.rm=TRUE),0,approx(x=ca_plot$conc, y=ca_plot$resp/norm_factor, xout=dat_eval_ca$conc, rule=2,ties="ordered")[[2]])
ia_y_eval <- approx(x=ia_plot$conc, y=ia_plot$resp, xout=dat_eval_ia$conc, rule=2)[[2]]
mp_eval <- toxcast_model(dat=potent_sing,params=potent_sing,XX=dat_eval_mp$conc)/norm_factor
# calculate RSS ratios
rss_ca <- sum((dat_eval_ca$resp/norm_factor - ca_y_eval)^2)/sum((dat_eval_ca$resp/norm_factor - toxcast_model(dat=mix_info,params=mix_info,XX=dat_eval_ca$conc)/norm_factor)^2)
rss_ia <- sum((dat_eval_ia$resp/norm_factor - ia_y_eval)^2)/sum((dat_eval_ia$resp/norm_factor - toxcast_model(dat=mix_info,params=mix_info,XX=dat_eval_ia$conc)/norm_factor)^2)
rss_mp <- sum((dat_eval_mp$resp/norm_factor - mp_eval)^2)/sum((dat_eval_mp$resp/norm_factor - toxcast_model(dat=mix_info,params=mix_info,XX=dat_eval_mp$conc)/norm_factor)^2)

print(paste0("RSS ratio CA = ",round(rss_ca,3)))
print(paste0("RSS ratio IA = ",round(rss_ia,3)))
print(paste0("RSS ratio MP = ",round(rss_mp,3)))
```


For the 95% bootstrapped confidence intervals around the modeled mixture concentration response, the performance can be evaluated by testing for interval overlap between the modeled intervals from the single components and the intervals from a direct bootstrap resampling procedure applied to the observed data. The 95% intervals are tested for overlap between the observed and modeled response intervals at each screened mixture cocnentration point. The bootstrap interval results are shown here, but the same procedure could be repeated for the 95% Bayesian credible intervals.

```{r}
# CA overlap
ca_eval_concs <- unique(subset(dat_eval, conc<=(min(max(ca_bootint_ex$X2.5., na.rm=TRUE),
                                             max(ca_bootint_ex$X97.5., na.rm=TRUE))+tol))$conc)
ca_overlap <- interval_overlap(curve_samples=ca_bootint_ex,
                               mix_curves=mix_bootint,
                               eval_concs=ca_eval_concs,norm_factor=norm_factor,
                               model_type='ca')
# IA overlap
ia_eval_concs <- unique(dat_eval_ia$conc)
ia_overlap <- interval_overlap(curve_samples=ia_bootint_ex,
                               mix_curves=ia_bootint_ex,
                               eval_concs=ia_eval_concs,norm_factor=norm_factor,
                               model_type='ia')
# MP overlap
sing_eval_concs <- unique(dat_eval_mp$conc)
sing_overlap <- interval_overlap(curve_samples=single_bootint_ex,
                               mix_curves=mix_bootint,
                               eval_concs=sing_eval_concs,norm_factor=norm_factor,
                               model_type='single')

```


To evaluate the 95% Bayesian prediction intervals, the coverage of the observed mixture data points by the interval is evaluated. 

```{r}

# mp_coverage <- sum(ifelse(dat_eval$resp>=single_predint_ex$X2.5. & dat_eval$resp<=single_predint_ex$X97.5.,1,0))/nrow(dat_eval)

```


