---
title: "Mixtures Analysis Summary"
author: "Rachel Broughton"
date: "2025-05-12"
output: html_document
---
# Setup Environment
```{r setup, include=FALSE,echo=FALSE,message=FALSE}
rm(list = ls())
# load packages
library(tidyverse)
library(data.table)
# library(dplyr)
# library(tidyr)
library(readxl)
library(tcplfit2)
library(tcpl)
library(grid)
library(cowplot)
library(scales)

# set up connections to ToxCast database
tcplConf("_dataminer", pass="pass", db="prod_internal_invitrodb_v4_2", drvr="MySQL", host="ccte-mysql-res.dmap-prod.aws.epa.gov")
tcplConfList()

# import scripts with functions
source("./scripts/curve_fitting_functions.R")
source("./scripts/mixture_model_functions.R")
source("./scripts/mixture_plotting_functions.R")
```

# Load Data for example

```{r}

# load test dataset spids
load("./input/mixture_spids.Rdata")
# load saved selected legacy spids instead of running each time
load("./input/legacy_spids.Rdata")
all_spids <- c(spids,spids_tc)

# read key for mapping mixtures to single components
ES219_key <- read_excel("./input/ATG_mixtures_upload.xlsx",  sheet = "ES219_key")
mixtures_uploads <- read_excel("./input/ATG_mixtures_upload.xlsx",  sheet = "Mixtures_upload")
mixtures_key <- merge(ES219_key, mixtures_uploads, by.x="BOTTLE_ID", by.y="Barcode_mixture")
# Add mixture concentration fractions to key
# compute concentration of component in stock mixture
mixtures_key <- mixtures_key %>% mutate(ci_mix = ALIQUOT_CONCENTRATION.y*Aliquot_Volume/Quantity)
# compute total concentration of stock mixture (from individual components)
ctot_mix <- rowsum(mixtures_key$ci_mix, as.integer(gl(nrow(mixtures_key), 2, nrow(mixtures_key))))
mixtures_key$ctot_mix <- rep(ctot_mix, each=2)
# compute concentration fraction of individual components in stock mixture
mixtures_key <- mixtures_key %>% mutate(cfrac_mix = ci_mix/ctot_mix)

# # load all mc5 data for Attagene endpoints
# mc5_attg_endpts <- tcplPrepOtpt(tcplLoadData(lvl=5, type = 'mc', fld='aeid',val=c(63:144)))
# # filter mc5 by tcplSubset selection for selecting legacy data
# tc_mc5_notmix <- mc5_attg_endpts %>% filter(!(spid %in% spids))
# setDT(tc_mc5_notmix)
# tc_mc5_notmix_filter <- tcplSubsetChid(tc_mc5_notmix)
# 
# mc5.test <- mc5_attg_endpts %>% filter(dsstox_substance_id %in% mixtures_key$DTXSID.y & (spid %in% spids))
# mc5.mixture <- mc5_attg_endpts %>% filter(dsstox_substance_id %in% mixtures_key$DTXSID.x)
# 
# mc5.legacy <- data.frame(matrix(NA,nrow=nrow(mc5.test), ncol=ncol(tc_mc5_notmix_filter)))
# colnames(mc5.legacy) <- colnames(tc_mc5_notmix_filter)
# for (ii in 1:nrow(mc5.test)){
#   mc5.legacy[ii,] <- tc_mc5_notmix_filter %>% filter(dsstox_substance_id==mc5.test$dsstox_substance_id[ii] & aeid==mc5.test$aeid[ii])
# }
# m4ids_all <- c(mc5.test$m4id,mc5.mixture$m4id,mc5.legacy$m4id)

# load m4id's for mixtures, test components, and legacy components
load("./input/m4ids_all.Rdata")
mc3 <- tcplPrepOtpt(tcplLoadData(lvl=3, type = 'mc', fld='spid',val=all_spids))
mc4 <- tcplPrepOtpt(tcplLoadData(lvl=4, type = 'mc', fld='m4id',val=m4ids_all))
mc4_agg <- tcplPrepOtpt(tcplLoadData(lvl="agg", type = 'mc', fld='m4id',val=m4ids_all))
mc5 <- tcplPrepOtpt(tcplLoadData(lvl=5, type = 'mc', fld='m4id',val=m4ids_all))

# load mix.info data frames with test dataset information
load("./output/mix_info.Rdata")
# load mix.info.tc data frames with legacy ToxCast data information
load("./output/mix_info_tc.Rdata")
# load single.info data frames with test dataset component information
load("./output/single_info.Rdata")
# load single.info.tc data frames with legacy ToxCast component information
load("./output/single_info_tc.Rdata")
# load mixture model results for ACC estimates
load("./output/mix_results_acc.Rdata")
#load mixture model results for full concentration-response curve predictions
load("./output/mix_results_all.Rdata")
# load quality-of-fit metric results
load("./output/fit_quality.Rdata")

```

# Single Chemical Components
## Fit with tcplfit2
Best fit concentration-response from tcplfit2 obtained via maximum likelihood estimation (MLE)
Concentration-response is in the invitrodb database and curve fit information is stored in mc5 of the ToxCast pipeline

Load concentration-response information from test dataset single components
```{r}
# select example mixture, based on m4id
# ex_index <- 154
m4id_mix <- 12663243
# relate mixture to single components and identify by m4id
dtxsids <- mixtures_key[mixtures_key$DTXSID.x == mc5[m4id==12663243,]$dsstox_substance_id, ]$DTXSID.y
m4id_1 <- mc5[(dsstox_substance_id==dtxsids[1] & aeid == mc5[m4id==12663243,]$aeid & (spid %in% spids)),]$m4id
m4id_2 <- mc5[(dsstox_substance_id==dtxsids[2] & aeid == mc5[m4id==12663243,]$aeid & (spid %in% spids)),]$m4id
# load concentration-response best fit curve information from tcpl level mc5
component1 <- mc5 %>% filter(m4id == m4id_1)
component2 <- mc5 %>% filter(m4id == m4id_2)
# load cocnentration-response data points from tcpl level mc3
comp1_data <- (mc3 %>% filter(m3id %in% mc4_agg[m4id==m4id_1,]$m3id))
comp2_data <- (mc3 %>% filter(m3id %in% mc4_agg[m4id==m4id_2,]$m3id))
# save concentration fractions
ci_frac <- mixtures_key[mixtures_key$DTXSID.x == mc5[m4id==12663243,]$dsstox_substance_id, ]$cfrac_mix
cfrac_1 <- ci_frac[1]
cfrac_2 <- ci_frac[2]

# calculate response for minimum to maximum tested concentrations based on tcplfit2 best fit model and parameters
curve1_plot <- data.frame(x=seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300),
                     resp=toxcast_model(dat=component1,params=component1,
                                        XX=seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)))
curve2_plot <- data.frame(x=seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300),
                     resp=toxcast_model(dat=component2,params=component2,
                                        XX=seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)))

# Define normalization factor to normalize curves to the maximum top value
# across entire endpoint to be able to compute and compare mixture models
# pull all mc5 top response values for the Attagene endpoint of this example
mc5_all <- tcplPrepOtpt(tcplLoadData(lvl=5, type = 'mc', fld='aeid',val=component1$aeid))
norm_factor <- max(mc5_all$top, na.rm=TRUE)

# # pull mixtures info and data
# mix_info <- mix.info.tc[mix.info.tc$m4id_mix==mix.results.all$m4id_mix[ex_index],]
mix_dat <- mc3 %>% filter(m3id %in% mc4_agg$m3id[which(mc4_agg$m4id==m4id_mix)])

```

Plot test dataset single components
```{r}
# set x-axis limits based on mixture data
lower_limit <- min(mix_dat$conc)
upper_limit <- max(mix_dat$conc)

p_outline <- ggplot() +
  # scale_x_log10(labels = label_number(drop0trailing = TRUE),
  #               limits= c(min(comp1_data$conc,comp2_data$conc),
  #                         max(comp1_data$conc,comp2_data$conc)))+
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=12) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(0.5,0.5,0.5,0.5), "cm"),
        plot.subtitle=element_text(hjust=0.5, size=11)) 

p1 <- p_outline +
    geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=2) +
    geom_line(data = curve1_plot, aes(x=x,y=resp/norm_factor),color="#D55E00", lwd=1.5) +
    labs(title="Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
    geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
    theme(plot.title=element_text(size=18,hjust=0.5, face="bold", color="#D55E00")) 

p2 <- p_outline +
    geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=2) +
    geom_line(data = curve2_plot, aes(x=x,y=resp/norm_factor),color="#009E73", lwd=1.5) +
    geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
    labs(title="Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
    theme(plot.title=element_text(size=18,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p1,p2)

```

## Fit with bootstrap resampling
```{r}
comp1_bootparams <- curve_bootstrap(curve.info=component1, boot_num=1000,type="single")
comp2_bootparams <- curve_bootstrap(curve.info=component2, boot_num=1000,type="single")

indices <- sample(1:1000,500)
p3 <- p_outline
  for(ii in 1:500){
  XX <- seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)
  boot_curve <- toxcast_model(dat=component1,params=comp1_bootparams[indices[ii],],XX=XX)
  p3 <- p3  +
    geom_line(data =data.frame(x=XX,y=boot_curve), aes(x=x,y=y/norm_factor),color="#D55E00", lwd=1, alpha=0.1)
}

p3 <- p3 +
  geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=1.5) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bootstrapped Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#D55E00")) 

indices <- sample(1:1000,500)
p4 <- p_outline
  for(ii in 1:500){
  XX <- seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)
  boot_curve <- toxcast_model(dat=component2,params=comp2_bootparams[indices[ii],],XX=XX)
  p4 <- p4  +
    geom_line(data =data.frame(x=XX,y=boot_curve), aes(x=x,y=y/norm_factor),color="#009E73", lwd=1, alpha=0.1)
}

p4 <- p4 +
  geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=1.5)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Boostrapped Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p3,p4)

```


## Fit with Bayesian statistical framework
```{r}
comp1_bayesparams <- bayes_curve(curve.info=component1,n_iter=10000,n_burn=10000,
                                  type="single",poly2_correct=FALSE)
comp2_bayesparams <- bayes_curve(curve.info=component2,n_iter=10000,n_burn=10000,
                                  type="single",poly2_correct=FALSE)

indices <- sample(1:10000,500)
p5 <- p_outline
  for(ii in 1:500){
  XX <- seq(min(comp1_data$conc),max(comp1_data$conc),length.out=300)
  curve1 <- toxcast_model(dat=component1,params=comp1_bayesparams[indices[ii],],XX=XX)
  p5 <- p5  +
    geom_line(data =data.frame(x=XX,y=curve1), aes(x=x,y=y/norm_factor),color="#D55E00", lwd=1, alpha=0.1)
}

p5 <- p5 +
  geom_point(data=comp1_data, aes(x = conc, y = resp/norm_factor),color="black",shape=15, size=1.5) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bayesian Component 1", subtitle = paste0(component1$chnm, ", ", component1$aenm)) +
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#D55E00")) 

indices <- sample(1:10000,500)
p6 <- p_outline
  for(ii in 1:500){
  XX <- seq(min(comp2_data$conc),max(comp2_data$conc),length.out=300)
  curve2 <- toxcast_model(dat=component2,params=comp2_bayesparams[indices[ii],],XX=XX)
  p6 <- p6  +
    geom_line(data =data.frame(x=XX,y=curve2), aes(x=x,y=y/norm_factor),color="#009E73", lwd=1, alpha=0.1)
}

p6 <- p6 +
  geom_point(data=comp2_data, aes(x = conc, y = resp/norm_factor),color="black",shape=17, size=1.5)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  labs(title="Bayesian Component 2", subtitle = paste0(component2$chnm, ", ", component2$aenm))+
  theme(plot.title=element_text(size=16,hjust=0.5, face="bold", color="#009E73")) 

plot_grid(p5,p6)
```


# Concentration Addition (CA)
## Model
$$
ACy_{mix} = (\frac{q_1}{ACy_{1}}+\frac{q_2}{ACy_{2}})^{-1}
$$
If $0.7*top_2 < y < top_1$, then
$$
ACy_{mix} = \frac{ACy_{1}}{q_1} \cdot (1-TU_2)
$$
## Example of predicted models

CA model derived from tcplfit2 best fit response
```{r}
ex_index <- which(mix.results.all$m4id_mix == m4id_mix)
cutoff <- component1$coff

# CA model derived from tcplfit2 best fit response
p1_og <- plotlines.func(index=ex_index,mix_input=mix.info,tc=FALSE) +
  guides(color=guide_legend(override.aes=list(lwd=1,size=2))) + 
  theme_bw(base_size=10) + 
  labs(title="CA Modeled Response") +
  theme(legend.position="none", axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm"),
        plot.title = element_text(size=11,hjust=0.5, face="bold"))

p1_og$layers[[6]] <- NULL
p1_og$layers[[5]] <- NULL
p1_og$layers[[4]] <- NULL
p1_og$layers[[3]] <- NULL
# p1_og$layers[[2]] <- NULL
p1_og$layers[[1]] <- NULL

p1_og <- p1_og +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1)
p1 <- ggplot_build(p1_og)
p1$data[[1]]$linewidth <- 1.5

p1_ca <- ggplot_gtable(p1)
# plot(p1_new)

```

CA model from bootstrap resampling 
```{r}
## Bootstrap CA implementation
num_pts <- 200
num_sample <- 1000

# get component 1 minimum and maximum response of tcplfit2 best fit response
comp1_min <- single_curve_min(dat=component1,params=component1)
comp1_top <- single_curve_top(dat=component1,params=component1) # top within concentration range, not true top
# set to small positive number if the minimum is negative. This happend for a concave up poly2 curve 
if (comp1_min <= 0){
  comp1_min <- 1E-20
}
# get component 2 minimum and maximum response of tcplfit2 best fit response
comp2_min <- single_curve_min(dat=component2,params=component2)
comp2_top <- single_curve_top(dat=component2,params=component2) # top within concentration range, not true top
if (comp2_min <= 0){
  comp2_min <- 1E-20
}
# set-up y-values to calculate CA line and x-values to calculate IA model
if(component1$hitc>=0.9 & component2$hitc<0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp1_min),log10(component1$coff),length.out=(2*num_pts/3)),
              seq(component1$coff+0.01,comp1_top,length.out=(num_pts/3)))
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- TRUE
  condition2 <- FALSE
}else if(component2$hitc>=0.9 & component1$hitc<0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp2_min),log10(component1$coff),length.out=(2*num_pts/3)),
              seq(component1$coff+0.01,comp2_top,length.out=(num_pts/3)))
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- FALSE
  condition2 <- TRUE
  }else if(component1$hitc>=0.9 & component2$hitc>=0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(max(comp1_min,comp2_min)),log10(component1$coff),length.out=(2*num_pts/3)),
              seq(component1$coff+0.01,max(comp1_top,comp2_top),length.out=(num_pts/3)))
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- TRUE
  condition2 <- TRUE
}
# compute full curve CA bootstrap 95% confidence interval
num_cols <- min(nrow(comp1_bootparams),nrow(comp2_bootparams))
ca_boot <- sapply(1:num_cols,ca_full_conc,YY=y_vals,comp1=component1,comp2=component2,
               params1=comp1_bootparams,params2=comp2_bootparams,cfrac1=cfrac_1,cfrac2=cfrac_2,
               condition1=condition1,condition2=condition2,sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bootint <- apply(ca_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_boot,1,mean,na.rm=TRUE)
ca_bootint_ex <- data.frame(resp=y_vals,mean=ca_mean,t(ca_bootint))

# Compute boostrap samples around ACC only
acc_boot_ca_ex <- sapply(1:num_cols,ca_point_conc,YY=component1$coff,comp1=component1,
                         comp2=component2,params1=comp1_bootparams,params2=comp2_bootparams,
                         cfrac1=cfrac_1,cfrac2=cfrac_2,condition1=condition1,
                         condition2=condition2,sample=TRUE)
p_outline <- ggplot() +
  # scale_x_log10(labels = label_number(drop0trailing = TRUE),
  #               limits= c(min(comp1_data$conc,comp2_data$conc),
  #                         max(comp1_data$conc,comp2_data$conc)))+
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=10) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm")) 

# set number of bootstrap curves to plot
num_plot <- 500
p2 <- p_outline +
  # plot 95% confidence interval
  geom_line(data=subset(ca_bootint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor),color="black",lwd=1)+
  geom_line(data=subset(ca_bootint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor),color="black",lwd=1)
for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=y_vals/norm_factor,conc=ca_boot[,jj]),conc>=0 & conc<=1000)
  p2 <- p2 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
}
p2_ca <- p2 +
  geom_line(data=subset(ca_bootint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_bootint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor,color="interval"),lwd=1.25) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bootstrap Resamples",interval="95% Confidence Interval"))+
  labs(title="Bootstrapped CA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
# print(p2)
```

CA model from Bayesian Approach
```{r}
## Bayesian CA implementation
num_pts <- 200
num_sample <- 1000
num_plot <- 50

# use same component minimum/maximum and y-values as bootstrap approach
indices <- sample(1:10000, num_sample, replace=F)
# compute full curve CA Bayesian 95% credible interval
ca_bayes <- sapply(indices,ca_full_conc,YY=y_vals,comp1=component1,comp2=component2,
               params1=comp1_bayesparams,params2=comp2_bayesparams,cfrac1=cfrac_1,
               cfrac2=cfrac_2,
               condition1=condition1,condition2=condition2,sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bayesint <- apply(ca_bayes, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_bayes,1,mean,na.rm=TRUE)
ca_bayesint_ex <- data.frame(resp=y_vals,mean=ca_mean,t(ca_bayesint))

# compute CA Bayesian 95% prediction interval
# y_vals_pred <- y_vals[((1:length(y_vals)) %%2)!=0]
y_vals_pred <- y_vals
capred_lo <- rep(NA, length(y_vals_pred))
capred_hi <- rep(NA, length(y_vals_pred))
x_pred_ca <- matrix(NA,nrow=length(y_vals_pred),ncol=num_sample)
for (zz in 1:length(y_vals_pred)){
  x_pred_ca[zz,] <- sapply(indices,ca_point_pred,YY=y_vals_pred[zz],comp1=component1,
                      comp2=component2,params1=comp1_bayesparams,
                      params2=comp2_bayesparams,cfrac1=cfrac_1,cfrac2=cfrac_2,
                      condition1=condition1,condition2=condition2)
  capred_lo[zz] <- quantile(x_pred_ca[zz,], prob=c(0.025,0.975), na.rm=TRUE)[1]
  capred_hi[zz] <- quantile(x_pred_ca[zz,], prob=c(0.025,0.975), na.rm=TRUE)[2]
}
ca_predint_ex <- data.frame(resp=y_vals_pred,lo=capred_lo,hi=capred_hi)

# Compute bayesian samples around ACC only
acc_bayes_ca_ex <- sapply(indices,ca_point_conc,YY=component1$coff,comp1=component1,
                         comp2=component2,params1=comp1_bayesparams,params2=comp2_bayesparams,
                         cfrac1=cfrac_1,cfrac2=cfrac_2,condition1=condition1,
                         condition2=condition2,sample=TRUE)

# set number of bayesian curves to plot
p3 <- p_outline
for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=y_vals/norm_factor,conc=ca_bayes[,jj]),conc>=0 & conc<=1000)
  p3 <- p3 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
}
p3_ca <- p3 +
  geom_line(data=subset(ca_bayesint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_bayesint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor,color="interval"),lwd=1.25) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bayesian Posterior Predictions",interval="95% Credible Interval"))+
  labs(title="Bayesian Approach CA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
# print(p3)

p4_ca <- p_outline
  # plot 95% prediction interval
# for(jj in 1:num_plot){
#   plot_data <- subset(data.frame(resp=y_vals_pred/norm_factor,conc=x_pred_ca[,jj]),conc>=0 & conc<=1000)
#   p4_ca <- p4_ca +
#     geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.2)
# }
for(jj in 1:length(y_vals_pred)){
  plot_data <- subset(data.frame(resp=rep(y_vals_pred[jj],length(x_pred_ca[jj,]))/norm_factor,conc=x_pred_ca[jj,]),conc>=0 & conc<=1000)
  p4_ca <- p4_ca +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.5)
}
p4_ca <- p4_ca +
  geom_line(data=subset(ca_predint_ex,lo>=0), aes(x=lo,y=resp/norm_factor,color="interval"),lwd=1.5)+
  geom_line(data=subset(ca_predint_ex,hi<=1000), aes(x=hi,y=resp/norm_factor,color="interval"),lwd=1.25) +
  # geom_point(data=subset(ca_predint_ex,lo>=0), aes(x=lo,y=resp/norm_factor,color="interval"),shape=108, size=4)+
  # geom_point(data=subset(ca_predint_ex,hi<=1000), aes(x=hi,y=resp/norm_factor,color="interval"),shape=108, size=4) +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#ffb000",interval="#b37b00"),labels=c(samples="Bayesian Posterior Predictions",interval="95% Prediction Interval"))+
  labs(title="Bayesian Prediction Interval CA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 3)))
```

Plot each fitting approach used to derive the CA model. Bootstrapped and Bayesian approaches are plotted as the curve samples and the 95% interval around the concentration-response. Note that the Bayesian posterior predictive samples are calculated and plotted as concentrations as a function of response

```{r}
# plot all together
# plot(p1_ca)
# print(p2_ca)
# print(p3_ca)
# print(p4_ca)
plot_grid(p1_ca,p2_ca,p3_ca,p4_ca,nrow=2,ncol=2)
```

# Independent Action (IA)

## Model

$$ A_{mix}(c_{mix}) = 1 - \prod_{i=1}^{2}(1-A_i(q_i*c_{mix})) $$

## Example
IA model derived from tcplfit2 best fit response
```{r}

# IA model derived from tcplfit2 best fit response
p_ia <- plotlines.func(index=ex_index,mix_input=mix.info,tc=FALSE) +
  guides(color=guide_legend(override.aes=list(lwd=2,size=4))) + 
  theme_bw(base_size=10) + 
  labs(title="IA Modeled Response") +
  theme(legend.position="none", axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm"),
        plot.title = element_text(size=11,hjust=0.5, face="bold"))

p_ia$layers[[6]] <- NULL
p_ia$layers[[5]] <- NULL
p_ia$layers[[4]] <- NULL
# p_ia$layers[[3]] <- NULL
p_ia$layers[[2]] <- NULL
p_ia$layers[[1]] <- NULL
p_ia <- p_ia +
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1)
p1_ia <- ggplot_build(p_ia)
p1_ia$data[[1]]$linewidth <- 1.5
p1_ia$data[[1]]$linetype <- 1

p1_ia <- ggplot_gtable(p1_ia)
# plot(p1_ia)

```

IA model bootstrap implementation
```{r}
p_outline <- ggplot() +
  # scale_x_log10(labels = label_number(drop0trailing = TRUE),
  #               limits= c(min(comp1_data$conc,comp2_data$conc),
  #                         max(comp1_data$conc,comp2_data$conc)))+
  scale_x_log10(labels = label_number(drop0trailing = TRUE)) +
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  labs(x=expression(paste("Concentration [",mu, "M]")), y="Normalized Response") +
  theme_bw(base_size=10) +
  theme(axis.text = element_text(color="black"),
        plot.margin=unit(c(2,5,2,5), "mm")) 

## Bootstrap CA implementation
num_pts <- 200
num_sample <- 1000

# set-up y-values to calculate CA line and x-values to calculate IA model
if(component1$hitc>=0.9 & component2$hitc<0.9){
  x_vals <- 10^seq(log10(mc5[m4id==m4id_mix,]$conc_min),
                   log10(component1$conc_max/cfrac_1),length.out=num_pts)
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- TRUE
  condition2 <- FALSE
}else if(component2$hitc>=0.9 & component1$hitc<0.9){
  x_vals <- 10^seq(log10(mc5[m4id==m4id_mix,]$conc_min),
                   log10(component2$conc_max/cfrac_2),length.out=num_pts)
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- FALSE
  condition2 <- TRUE
  }else if(component1$hitc>=0.9 & component2$hitc>=0.9){
    x_vals <- 10^seq(log10(mc5[m4id==m4id_mix,]$conc_min),
                       log10(min(component1$conc_max/cfrac_1,component2$conc_max/cfrac_2)),
                       length.out=num_pts)
  # set activity hitcalls as true/false for faster evaluation
  condition1 <- TRUE
  condition2 <- TRUE
  }

# compute full curve IA bootstrap 95% confidence interval
ia_boot <- sapply(c(1:min(nrow(comp1_bootparams),nrow(comp2_bootparams))),ia_full_resp,
                  val=x_vals,comp1=component1,comp2=component2,
                  params1=comp1_bootparams,params2=comp2_bootparams,
                  cfrac1=cfrac_1,cfrac2=cfrac_2,
                  condition1=condition1,condition2=condition2,
                  norm_factor=norm_factor,sample=TRUE)
ia_bootint <- apply(ia_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_mean <- apply(ia_boot,1,mean,na.rm=TRUE)
ia_bootint_ex <- data.frame(conc=x_vals,mean=ia_mean,t(ia_bootint))
# Compute bootstrap samples around ACC only


# set number of bootstrap curves to plot
num_plot <- 50
p_ia_2 <- p_outline
  # plot 95% confidence interval

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_boot[,jj],conc=x_vals))
  p_ia_2 <- p_ia_2 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.05)
}
p_ia_2 <- p_ia_2 +
  geom_line(data=ia_bootint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_bootint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#006299",interval="#00314d"),labels=c(samples="Bootstrap Resamples",interval="95% Confidence Interval"))+
  labs(title="Bootstrapped IA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
# print(p_ia_2)
```

IA model Bayesian implementation
```{r}
# compute full curve IA Bayesian 95% credible interval
indices <- sample(1:10000, num_sample, replace=F)
ia_bayes <- sapply(indices,ia_full_resp,
                   val=x_vals,comp1=component1,comp2=component2,
                   params1=comp1_bayesparams,params2=comp2_bayesparams,
                   cfrac1=cfrac_1,cfrac2=cfrac_2,
                   condition1=condition1,condition2=condition2,
                   norm_factor=norm_factor,sample=TRUE)
ia_credint <- apply(ia_bayes, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_bayes_mean <- apply(ia_bayes,1,mean,na.rm=TRUE)
ia_bayesint_ex <- data.frame(conc=x_vals,mean=ia_bayes_mean,t(ia_credint))
# compute full curve IA Bayesian 95% prediction interval
ia_pred_curve <- sapply(indices, ia_full_pred, comp1=component1,comp2=component2,
                   cfrac1=cfrac_1,cfrac2=cfrac_2,params1=comp1_bayesparams,
                   params2=comp2_bayesparams,norm_factor=norm_factor, x_vals=x_vals,
                   condition1=condition1,condition2=condition2)

# get prediction interval
iapred_int <- apply(ia_pred_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_predint_ex <- data.frame(conc=x_vals,t(iapred_int))

# Compute Bayesian samples around ACC only
acc_bayes_ia <- c()
for (ss in 1:num_sample){
  if (sum(!is.na(ia_bayes[,ss]))==0){
    acc_ia_bayes_temp <- NA
  } else{
    # cutoff IA at top (don't include biphasic part)
    ia_resp <- ia_bayes[,ss][1:which.max(ia_bayes[,ss])]
    x_vals_eval <- x_vals[1:which.max(ia_resp)]
    if (max(ia_resp,na.rm=TRUE)<(component1$coff/norm_factor)){
      acc_ia_bayes_temp <- 10000
    } else if (min(ia_resp,na.rm=TRUE)>(component1$coff/norm_factor)){
      acc_ia_bayes_temp <- -10000
    } else {
      acc_ia_bayes_temp <- approx(x=ia_resp,y=x_vals_eval, 
                                  xout=component1$coff/norm_factor,
                                  rule=1,ties="ordered")[[2]]
    }
  }
  acc_bayes_ia <- append(acc_bayes_ia,acc_ia_bayes_temp)
}


# set number of Bayesian curves to plot
num_plot <- 50
# plot 95% credible interval
p_ia_3 <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_bayes[,jj],conc=x_vals))
  p_ia_3 <- p_ia_3 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.05)
}
p_ia_3 <- p_ia_3 +
  geom_line(data=ia_bayesint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_bayesint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#006299",interval="#00314d"),labels=c(samples="Bayesian Samples",interval="95% Credible Interval"))+
  labs(title="Bayesian Approach IA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
# print(p_ia_3)

# plot 95% prediction interval
p_ia_4 <- p_outline

for(jj in 1:num_plot){
  plot_data <- subset(data.frame(resp=ia_pred_curve[,jj],conc=x_vals))
  p_ia_4 <- p_ia_4 +
    geom_line(data=plot_data,aes(x=conc,y=resp,color="samples"),alpha=0.3)
}
p_ia_4 <- p_ia_4 +
  geom_line(data=ia_predint_ex, aes(x=conc,y=X2.5.,color="interval"),lwd=1)+
  geom_line(data=ia_predint_ex, aes(x=conc,y=X97.5.,color="interval"),lwd=1)+
  geom_hline(yintercept=component1$coff/norm_factor, linetype="dashed", color="gray34",linewidth=1) +
  scale_color_manual(values=c(samples="#CDEDFF",interval="#006299"),labels=c(samples="Bayesian Predictive Samples",interval="95% Prediction Interval"))+
  labs(title="Bayesian Prediction Interval IA") +
  theme(plot.title = element_text(size=11,hjust=0.5, face="bold"),
        legend.title=element_blank(),
        legend.background = element_rect(fill=NA),
        legend.text = element_text(size=8),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(4, "mm"),
        legend.key.height = unit(2, "mm")) + 
  guides(color = guide_legend(override.aes = list(linewidth = 2)))
# print(p_ia_4)
  
```

Plot all IA methods together
```{r}
# plot(p1_ia)
# print(p_ia_2)
# print(p_ia_3)
plot_grid(p1_ia,p_ia_2,p_ia_3,p_ia_4,nrow=2,ncol=2)
```

# Most Potent Single Component (MP)

## Model

Mixtures is treated as being made up 100% of the most potent single chemical component. The most potent chemical component is selected as the component with the lower activity concentration at the cutoff (ACC), which is the selected point of departure.

## Example

# Compare Models to Observed Mixture

## Fit the observed mixture concentration-response
Obtain the observed mixture tcplfit2 best fit model, bootstrapped 95% confidence interval, and Bayesian 95% credible interval
```{r}
# tcplfit2 best fit response
mix_info <- mc5 %>% filter(m4id == m4id_mix)
mix_info$m4id_mix <- m4id_mix
# bootstrap resampling of observed mixture
mix_bootparams <- curve_bootstrap(curve.info=mix_info, boot_num=1000, type="mix")
x_vals <- 10^seq(log10(0.01*mix_info$conc_min),log10(3*mix_info$conc_max),length.out=num_pts)
# bootstrap 95% confidence interval on concentration-response
mix_curve <- sapply(c(1:nrow(mix_bootparams)), toxcast_model,
                      dat=mix_info,params=mix_bootparams,XX=x_vals,sample=TRUE)
mix_bootint <- apply(mix_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
mix_bootint <- data.frame(conc=x_vals,t(mix_bootint))
# bootstrapped distribution around ACC
acc <- rep(NA,nrow(mix_bootparams))
for (ss in 1:nrow(mix_bootparams)){
  params <- mix_bootparams[ss,]
  top_val <- single_curve_top(dat=mix_info,params=params)
  min_val <- min(mix_curve[,ss],na.rm=T)
  if (top_val<0){
    acc[ss] <- NA
  } else {
    if (top_val<mix_info$coff){
      if (mix_info$modl %in% c("poly1","pow","exp2","exp3")){
        acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
      } else if(mix_dat$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
        } else{
          acc[ss] <- 10000
        }
      } else {
        acc[ss] <- 10000
      }
    } else if (min_val>mix_info$coff){
      acc[ss] <- -10000
    } else{
      acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
    }
  }
}
mix_acc_boot <- acc

# Bayesian approach to fitting the observed mixture concentration-response
mix_bayesparams <- bayes_curve(curve.info=mix_info, n_iter=10000, n_burn=2000,
                               type="mix", poly2_correct=FALSE, tc=FALSE)
indices <- sample(1:10000, num_sample, replace=F)
mix_curve <- sapply(indices, toxcast_model,
                    dat=mix_info,params=mix_bayesparams,XX=x_vals,sample=TRUE)
mix_bayesint <- apply(mix_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
mix_bayesint <- list(data.frame(conc=x_vals,t(mix_bayesint)))

acc <- rep(NA,num_sample)
for (ss in 1:num_sample){
  params <- mix_bayesparams[indices[ss],]
  top_val <- single_curve_top(dat=mix_info,params=params)
  min_val <- min(mix_curve[,ss],na.rm=T)
  if (top_val<0){
    acc[ss] <- NA
  } else {
    if (top_val<mix_info$coff){
      if (mix_info$modl %in% c("poly1","pow","exp2","exp3")){
        acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
      } else if(mix_info$modl=='poly2'){
        # all poly2 curves can extend except for the concave down increasing
        if (!(params$a<0 & params$b<0)){
          acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
        } else{
          acc[ss] <- 10000
        }
      } else {
        acc[ss] <- 10000
      } 
    } else if (min_val>mix_info$coff){
      acc[ss] <- -10000
    } else{
      acc[ss] <- single_curve_inv(y=mix_info$coff,params=params,single_dat=mix_info)
    }
  }
  
}
mix_acc_bayes <- acc
```

## Visual comparison of models to observed mixture

```{r}
p_compare <- plotint.func(index=ex_index,tc=FALSE) +
                      guides(color=guide_legend(override.aes=list(lwd=2,size=4)),
                      fill=guide_legend(override.aes=list(lwd=0.5))) + 
                      theme_bw(base_size=16) +
  theme(legend.title=element_blank(),
        legend.text = element_text(size=12),
        legend.background = element_rect(fill=NA),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='cm'),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(1, "cm"),
        legend.key.height = unit(0.2, "cm"),
        legend.spacing.y = unit(-0.3, "cm"),
        axis.text = element_text(color="black"),
        plot.margin = margin(t=1, r=1.5,b=0,l=1.5, unit = "cm"),
        plot.title = element_blank())

acc_ca_density <- density(mix.results.acc$acc_boot_ca.tc[[ex_index]])
acc_mix_density <- density(mix.results.acc$acc_boot_mix[[ex_index]])
p3 <- p3 +
  geom_line(data=data.frame(x=acc_ca_density$x,y=acc_ca_density$y),aes(x=x,y=((y)+(cutoff/norm_factor))),color="darkorange3",lwd=1.25)+
  annotate("text", x=mix.results.acc$acc_ca.tc[ex_index]+30, y=cutoff/norm_factor+0.12, label='bold(ACC[Model-CA])',
           parse=TRUE,angle=0,size=4,color="darkorange3")+
  geom_line(data=data.frame(x=acc_mix_density$x,y=acc_mix_density$y),aes(x=x,y=((y)+(cutoff/norm_factor))),color="black",lwd=1.25)+
  annotate("text", x=mix.results.acc$acc_mix[ex_index], y=cutoff/norm_factor+0.28, label='bold(ACC[Obs])',
           parse=TRUE,angle=0,size=4,color="black")+
  annotate("text",x=0.13,y=cutoff/norm_factor+0.04,label="Cutoff",size=4,color="black")

p3_new <- ggplot_build(p3)
p3_new$data[[1]]$linewidth <- 0.5
p3_new$data[[2]]$linewidth <- 0.5
p3_new$data[[3]]$linewidth <- 1.5
p3_new$data[[4]]$size <- 2
p3_new_plot <- ggplot_gtable(p3_new)
plot(p3_new_plot)
```

## Quality-of-Fit Metrics


## Implementation for full curve

## Implementation for one response value

The ACC for the CA model is calculated directly from the ACC values of the component curves because the CA model results in a concentration for a given response level.

```{r}
ex_index <- 54
cutoff <- subset(mc5_attg_endpts, m4id == mix.results.all$m4id_mix[ex_index])$coff
norm_factor <- subset(mix.info.tc, m4id_mix == mix.results.all$m4id_mix[ex_index])$edpt_top
p2_og <- ggplot_build(plotlines.func(index=ex_index,tc=TRUE) +
                      guides(color=guide_legend(override.aes=list(lwd=2,size=4))) + 
                      geom_errorbarh(aes(xmax=mix.results.acc$acc_ca.tc[ex_index],
                                         xmin=mix.results.acc$acc_mix[ex_index],
                                         y=cutoff/norm_factor,height=0.1),color="red",lwd=1.5)+
                      # add annotation for ACC_model
                      geom_vline(xintercept=mix.results.acc$acc_ca.tc[ex_index],color="red",lty=2,lwd=1.25)+
                      # geom_segment(aes(x=mix.results.acc$acc_ca.tc[ex_index],
                      #                  xend=mix.results.acc$acc_ca.tc[ex_index],
                      #                  y=-0.2,yend=cutoff/norm_factor),color="red",lty=2,lwd=1.25)+
                      annotate("text", x=mix.results.acc$acc_ca.tc[ex_index]+17, y=-0.05, label='bold(ACC[Model-CA])', parse=TRUE,angle=0,size=4)+
                      # add annotation for ACC_mix
                      geom_vline(xintercept=mix.results.acc$acc_mix[ex_index],color="red",lty=2,lwd=1.25)+
                      # geom_segment(aes(x=mix.results.acc$acc_mix[ex_index],
                      #                  xend=mix.results.acc$acc_mix[ex_index],
                      #                  y=-0.2,yend=cutoff/norm_factor),color="red",lty=2,lwd=1.25)+
                      annotate("text", x=mix.results.acc$acc_mix[ex_index]-3, y=-0.05, label='bold(ACC[Obs])', parse=TRUE,angle=0,size=4)+
                      theme_bw(base_size=16) + theme(legend.title=element_blank(),
                                                     legend.text = element_text(size=14),
                                                     legend.background = element_rect(fill=NA),
                                                     legend.margin = margin(0.1,0.1,0.1,0.1, unit='cm'),
                                                     legend.justification = c(0,1),
                                                     legend.position = "inside",
                                                     legend.position.inside=c(0.01,0.99),
                                                     legend.key.width = unit(2, "cm"),
                                                     legend.key.height = unit(0.3, "cm"),
                                                     axis.text = element_text(color="black"),
                                                     plot.margin = margin(t=1, r=1.5,b=0,l=1.5, unit = "cm"),
                                                     plot.title = element_blank()))
p2_og$data[[1]]$linewidth <- 1.5
p2_og$data[[2]]$linewidth <- 1.5
p2_og$data[[3]]$linewidth <- 1.5
p2_og$data[[4]]$linewidth <- 1.5
p2_og$data[[5]]$linewidth <- 1.5
p2_og$data[[6]]$size <- 3
p2 <- ggplot_gtable(p2_og)
plot(p2)
```

## Bootstrap CA implementation
```{r}
ii <- 1 # index of example
num_pts <- 200
num_sample <- 1000
# Compute full curves for legacy ToxCast data
mix_info <- mix.info.tc[mix.info.tc$m4id_mix==mix.results.all$m4id_mix[ii],]
comp1 <- mc5[m4id==mix_info$m4id_1]
comp2 <- mc5[m4id==mix_info$m4id_2]
# pull mixtures observed data points for CA prediction interval calculation
mix_dat <- mc3 %>% filter(m3id %in% mc4_agg$m3id[which(mc4_agg$m4id==mix_info$m4id_mix)])
# if curve is poly2 and concave up (negative in concentration range), then replace with alternative curve shape
if (comp1$hitc >= 0.9 & comp1$modl=='poly2' & comp1$a>0 & comp1$b<0){
  params1 <- poly2_new_modl[m4id==mix_info$m4id_1,]
  bootparams1 <- poly2_new_modl[m4id==mix_info$m4id_1,]$bootparams[[1]]
  bayesparams1 <- poly2_new_modl[m4id==mix_info$m4id_1,]$bayesparams[[1]]
  comp1$modl <- poly2_new_modl[m4id==mix_info$m4id_1,]$modl
} else {
  params1 <- comp1
  bootparams1 <- subset(single.info.tc,m4id==mix_info$m4id_1)$bootparams[[1]]
  bayesparams1 <- subset(single.info.tc,m4id==mix_info$m4id_1)$bayesparams[[1]]
}
if (comp2$hitc >= 0.9 & comp2$modl=='poly2' & comp2$a>0 & comp2$b<0){
  params2 <- poly2_new_modl[m4id==mix_info$m4id_2,]
  bootparams2 <- poly2_new_modl[m4id==mix_info$m4id_2,]$bootparams[[1]]
  bayesparams2 <- poly2_new_modl[m4id==mix_info$m4id_2,]$bayesparams[[1]]
  comp2$modl <- poly2_new_modl[m4id==mix_info$m4id_2,]$modl
} else {
  params2 <- comp2
  bootparams2 <- subset(single.info.tc,m4id==mix_info$m4id_2)$bootparams[[1]]
  bayesparams2 <- subset(single.info.tc,m4id==mix_info$m4id_2)$bayesparams[[1]]
}
cfrac1 <- mix_info$cfrac_1
cfrac2 <- mix_info$cfrac_2
comp1_min <- single_curve_min(dat=comp1,params=params1) + 1E-20 # add to avoid zero
comp1_top <- single_curve_top(dat=comp1,params=params1) # top within concentration range, not true top
# set to small positive number if the minimum is negative. This happend for a concave up poly2 curve 
if (comp1_min < 0){
  comp1_min <- 1E-20
}
comp2_min <- single_curve_min(dat=comp2,params=params2) + 1E-20 # add to avoid zero
comp2_top <- single_curve_top(dat=comp2,params=params2) # top within concentration range, not true top
if (comp2_min <0){
  comp2_min <- 1E-20
}
# set-up y-values to calculate CA line and x-values to calculate IA model
if(comp1$hitc>=0.9 & comp2$hitc<0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp1_min),log10(mix_info$coff),length.out=(2*num_pts/3)),seq(mix_info$coff+0.01,comp1_top,length.out=(num_pts/3)))
}else if(comp2$hitc>=0.9 & comp1$hitc<0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp2_min),log10(mix_info$coff),length.out=(2*num_pts/3)),seq(mix_info$coff+0.01,comp2_top,length.out=(num_pts/3)))
}else if(comp1$hitc>=0.9 & comp2$hitc>=0.9){
  # put response values from minimum response (~0) to the cutoff on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(max(comp1_min,comp2_min)),log10(mix_info$coff),length.out=(2*num_pts/3)),
              seq(mix_info$coff+0.01,max(comp1_top,comp2_top),length.out=(num_pts/3)))
}
# compute full curve CA bootstrap 95% confidence interval
num_cols <- min(nrow(bootparams1),nrow(bootparams2))
ca_boot <- sapply(1:num_cols,ca_full_conc,YY=y_vals,comp1=comp1,comp2=comp2,
               params1=bootparams1,params2=bootparams2,cfrac1=cfrac1,cfrac2=cfrac2,
               condition1=mix_info$condition1,condition2=mix_info$condition2,
               sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bootint <- apply(ca_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_boot,1,mean,na.rm=TRUE)
ca_bootint_ex <- data.frame(resp=y_vals,mean=ca_mean,t(ca_bootint))

# Compute boostrap samples around ACC only
acc_boot_ca_ex <- sapply(1:num_cols,ca_point_conc,YY=comp1$coff,comp1=comp1,
                         comp2=comp2,params1=bootparams1,params2=bootparams2,
                         cfrac1=cfrac1,cfrac2=cfrac2,condition1=mix_info$condition1,
                         condition2=mix_info$condition2,sample=TRUE)
```

Plot example bootstrap resampled curves
```{r}
ex_index <- ii
coff <- subset(mc5, m4id == mix.results.all$m4id_mix[ex_index])$coff
# norm_factor <- subset(mix.info.tc, m4id_mix == mix.results.all$m4id_mix[ex_index])$edpt_top
# set x-axis limits
lower_limit <- min(mix_dat$conc)
upper_limit <- max(mix_dat$conc)
p1 <- ggplot() +
  theme_bw(base_size=16) +
  # plot 95% confidence interval
  geom_line(data=subset(ca_bootint_ex,X2.5.>=0), aes(x=X2.5.,y=resp/norm_factor),color="black",lwd=1)+
  geom_line(data=subset(ca_bootint_ex,X97.5.<=1000), aes(x=X97.5.,y=resp/norm_factor),color="black",lwd=1)+
  geom_hline(yintercept=coff/norm_factor, linetype=2, color="gray34") +
  geom_point(data = mix_dat, aes(x = mix_dat$conc, y = mix_dat$resp/norm_factor), color="black",shape=19, size=1) + 
  scale_x_log10(labels = label_number(drop0trailing = TRUE))+
  coord_cartesian(xlim=c(lower_limit,upper_limit))+
  theme(legend.title=element_blank(),
        legend.text = element_text(size=14),
        legend.background = element_rect(fill=NA),
        legend.margin = margin(0.1,0.1,0.1,0.1, unit='cm'),
        legend.justification = c(0,1),
        legend.position = "inside",
        legend.position.inside=c(0.01,0.99),
        legend.key.width = unit(2, "cm"),
        legend.key.height = unit(0.3, "cm"),
        axis.text = element_text(color="black"),
        plot.margin = margin(t=1, r=1.5,b=0,l=1.5, unit = "cm"),
        plot.title = element_blank())
for(jj in 1:num_cols){
  plot_data <- subset(data.frame(resp=y_vals/norm_factor,conc=ca_boot[,jj]),conc>=0 & conc<=1000)
  p1 <- p1 +
    geom_line(data=plot_data,aes(x=conc,y=resp),color="orange",alpha=0.2)
}
print(p1)

```

# Independent Action (IA)
## Model
$$ A_{mix}(c_{mix}) = 1 - \prod_{i=1}^{2}(1-A_i(q_i*c_{mix})) $$
Most potent single component model

Bootstrap
Bayesian
Bayesian prediction interval

Fit criteria development

# Sticking points
1) +/- 10,000 for CA
2) +/- 10,000 for IA

```{r}
ii <- 1 # index of example
num_pts <- 200
num_sample <- 1000
# Compute full curves for legacy ToxCast data
mix_info <- mix.info.tc[mix.info.tc$m4id_mix==mix.results.all$m4id_mix[ii],]
comp1 <- mc5_attg_endpts[m4id==mix_info$m4id_1]
comp2 <- mc5_attg_endpts[m4id==mix_info$m4id_2]
# pull mixtures observed data points for CA prediction interval calculation
mix_dat <- mc3 %>% filter(m3id %in% mc4_agg$m3id[which(mc4_agg$m4id==mix_info$m4id_mix)])
# select observed mixture data up to mixture top (monotonic part only) for CA pred int calculation
mix_model_xvals <- seq(min(mix_dat$conc),max(mix_dat$conc),length.out=500)
mix_model <- toxcast_model(dat=mc5[m4id==mix_info$m4id_mix,],
                           params=mc5[m4id==mix_info$m4id_mix,],
                           XX=mix_model_xvals)
mix_top_loc <- mix_model_xvals[which.max(mix_model)]
dat_ca_eval_full <- subset(select(mix_dat,c(conc,resp)), conc<=mix_top_loc)
# if curve is poly2 and concave up (negative in concentration range), then replace with alternative curve shape
if (comp1$hitc >= 0.9 & comp1$modl=='poly2' & comp1$a>0 & comp1$b<0){
  params1 <- poly2_new_modl[m4id==mix_info$m4id_1,]
  bootparams1 <- poly2_new_modl[m4id==mix_info$m4id_1,]$bootparams[[1]]
  bayesparams1 <- poly2_new_modl[m4id==mix_info$m4id_1,]$bayesparams[[1]]
  comp1$modl <- poly2_new_modl[m4id==mix_info$m4id_1,]$modl
} else {
  params1 <- comp1
  bootparams1 <- subset(single.info.tc,m4id==mix_info$m4id_1)$bootparams[[1]]
  bayesparams1 <- subset(single.info.tc,m4id==mix_info$m4id_1)$bayesparams[[1]]
}
if (comp2$hitc >= 0.9 & comp2$modl=='poly2' & comp2$a>0 & comp2$b<0){
  params2 <- poly2_new_modl[m4id==mix_info$m4id_2,]
  bootparams2 <- poly2_new_modl[m4id==mix_info$m4id_2,]$bootparams[[1]]
  bayesparams2 <- poly2_new_modl[m4id==mix_info$m4id_2,]$bayesparams[[1]]
  comp2$modl <- poly2_new_modl[m4id==mix_info$m4id_2,]$modl
} else {
  params2 <- comp2
  bootparams2 <- subset(single.info.tc,m4id==mix_info$m4id_2)$bootparams[[1]]
  bayesparams2 <- subset(single.info.tc,m4id==mix_info$m4id_2)$bayesparams[[1]]
}
cfrac1 <- mix_info$cfrac_1
cfrac2 <- mix_info$cfrac_2
comp1_min <- single_curve_min(dat=comp1,params=params1) + 1E-20 # add to avoid zero
comp1_top <- single_curve_top(dat=comp1,params=params1) # top within concentration range, not true top
# set to small positive number if the minimum is negative. This happend for a concave up poly2 curve 
if (comp1_min < 0){
  comp1_min <- 1E-20
}
comp2_min <- single_curve_min(dat=comp2,params=params2) + 1E-20 # add to avoid zero
comp2_top <- single_curve_top(dat=comp2,params=params2) # top within concentration range, not true top
if (comp2_min <0){
  comp2_min <- 1E-20
}
# set-up y-values to calculate CA line and x-values to calculate IA model
if(comp1$hitc>=0.9 & comp2$hitc<0.9){
  # put response values from 0-1 on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp1_min),log10(mix_info$coff),length.out=(2*num_pts/3)),seq(mix_info$coff+0.01,comp1_top,length.out=(num_pts/3)))
  x_vals <- 10^seq(log10(mc5[m4id==mix.results.all$m4id_mix[ii],]$conc_min),log10(comp1$conc_max/cfrac1),length.out=num_pts)
  dat_ca_eval <- subset(dat_ca_eval_full,resp<=comp1_top)
}else if(comp2$hitc>=0.9 & comp1$hitc<0.9){
  # put response values from 0-1 on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(comp2_min),log10(mix_info$coff),length.out=(2*num_pts/3)),seq(mix_info$coff+0.01,comp2_top,length.out=(num_pts/3)))
  x_vals <- 10^seq(log10(mc5[m4id==mix.results.all$m4id_mix[ii],]$conc_min),log10(comp2$conc_max/cfrac2),length.out=num_pts)
  dat_ca_eval <- subset(dat_ca_eval_full,resp<=comp2_top)
}else if(comp1$hitc>=0.9 & comp2$hitc>=0.9){
  # put response values from 0-1 on a log scale and the rest with even spacing to get good coverage of points
  y_vals <- c(10^seq(log10(max(comp1_min,comp2_min)),log10(mix_info$coff),length.out=(2*num_pts/3)),
              seq(mix_info$coff+0.01,max(comp1_top,comp2_top),length.out=(num_pts/3)))
  x_vals <- 10^seq(log10(mc5[m4id==mix.results.all$m4id_mix[ii],]$conc_min),
                   log10(min(comp1$conc_max/cfrac1,comp2$conc_max/cfrac2)),
                   length.out=num_pts)
  dat_ca_eval <- subset(dat_ca_eval_full,resp<=max(comp1_top,comp2_top))
}
# Compute full curve CA line model
ca_concs <- ca_full_conc(YY=y_vals,comp1=comp1,comp2=comp2,params1=params1,
                         params2=params2,cfrac1=cfrac1,cfrac2=cfrac2,
                         condition1=mix_info$condition1,
                         condition2=mix_info$condition2,sample=FALSE)

ca_curve_ex <- data.frame(conc=ca_concs,resp=y_vals)
# compute full curve CA bootstrap 95% confidence interval
num_cols <- min(nrow(bootparams1),nrow(bootparams2))
ca_boot <- sapply(1:num_cols,ca_full_conc,YY=y_vals,comp1=comp1,comp2=comp2,
               params1=bootparams1,params2=bootparams2,cfrac1=cfrac1,cfrac2=cfrac2,
               condition1=mix_info$condition1,condition2=mix_info$condition2,
               sample=TRUE)
# could select a different type of quantile. (ex. Choose so that -10000 or 10000 is never selected)
ca_bootint <- apply(ca_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ca_mean <- apply(ca_boot,1,mean,na.rm=TRUE)
ca_bootint_ex <- list(data.frame(resp=y_vals,mean=ca_mean,t(ca_bootint)))
# compute full curve CA Bayesian 95% credible interval
indices <- sample(1:10000, num_sample, replace=F)
ca_bayes <- sapply(indices,ca_full_conc,YY=y_vals,comp1=comp1,comp2=comp2,
               params1=bayesparams1,params2=bayesparams2,cfrac1=cfrac1,cfrac2=cfrac2,
               condition1=mix_info$condition1,condition2=mix_info$condition2,
               sample=TRUE)
ca_credint <- apply(ca_bayes, 1, quantile, prob=c(0.025,0.975),na.rm=TRUE)
ca_bayes_mean <- apply(ca_bayes,1,mean,na.rm=TRUE)
ca_bayesint_ex <- data.frame(resp=y_vals,mean=ca_bayes_mean,t(ca_credint))
# calculate CA 95% prediction interval at observed response levels only (to save time and for easier computation)
dat_ca_eval$capred_lo <- NA
dat_ca_eval$capred_hi <- NA
for (zz in 1:nrow(dat_ca_eval)){
  y_pred_ca <- sapply(indices,ca_point_pred,YY=dat_ca_eval$resp[zz],comp1=comp1,
                        comp2=comp2,params1_samp=bayesparams1,params2_samp=bayesparams2,
                        cfrac1=cfrac1,cfrac2=cfrac2,condition1=mix_info$condition1,
                        condition2=mix_info$condition2)
  dat_ca_eval$capred_lo[zz] <- quantile(y_pred_ca, prob=c(0.025,0.975), na.rm=TRUE)[1]
  dat_ca_eval$capred_hi[zz] <- quantile(y_pred_ca, prob=c(0.025,0.975), na.rm=TRUE)[2]
}
ca_predint_ex <- dat_ca_eval

# compute full curve IA line model
ia_resps <- ia_full_resp(val=x_vals,comp1=comp1,comp2=comp2,params1=params1,params2=params2,
                         cfrac1=cfrac1,cfrac2=cfrac2,condition1=mix_info$condition1,
                         condition2=mix_info$condition2,norm_factor=mix_info$edpt_top,sample=FALSE)
ia_curve_ex <- data.frame(conc=x_vals,resp=ia_resps)
# compute full curve IA bootstrap 95% confidence interval
ia_boot <- sapply(c(1:min(nrow(bootparams1),nrow(bootparams2))),ia_full_resp,
                   val=x_vals,comp1=comp1,comp2=comp2,params1=bootparams1,
                   params2=bootparams2,cfrac1=mix_info$cfrac_1,cfrac2=mix_info$cfrac_2,
                   condition1=mix_info$condition1,condition2=mix_info$condition2,
                   norm_factor=mix_info$edpt_top,sample=TRUE)
ia_bootint <- apply(ia_boot, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_mean <- apply(ia_boot,1,mean,na.rm=TRUE)
ia_boot_ex <- data.frame(conc=x_vals,mean=ia_mean,t(ia_bootint))
# compute full curve IA Bayesian 95% credible interval
ia_bayes <- sapply(indices,ia_full_resp,
                   val=x_vals,comp1=comp1,comp2=comp2,params1=bayesparams1,
                   params2=bayesparams2,cfrac1=mix_info$cfrac_1,cfrac2=mix_info$cfrac_2,
                   condition1=mix_info$condition1,condition2=mix_info$condition2,
                   norm_factor=mix_info$edpt_top,sample=TRUE)
ia_credint <- apply(ia_bayes, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_bayes_mean <- apply(ia_bayes,1,mean,na.rm=TRUE)
ia_bayesint_ex <- data.frame(conc=x_vals,mean=ia_bayes_mean,t(ia_credint))
# compute full curve IA Bayesian 95% prediction interval
ia_pred_curve <- sapply(indices, ia_full_pred, comp1=comp1,comp2=comp2,
                   cfrac1=cfrac1,cfrac2=cfrac2,params1=bayesparams1,
                   params2=bayesparams2,norm_factor=mix_info$edpt_top, x_vals=x_vals,
                   condition1=mix_info$condition1,condition2=mix_info$condition2)
# get prediction interval
iapred_int <- apply(ia_pred_curve, 1, quantile, prob=c(0.025,0.975), na.rm=TRUE)
ia_predint_ex <- data.frame(conc=x_vals,t(iapred_int))
```
